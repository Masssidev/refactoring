# 데이터 체계화
### 필드 자체 캡슐화
*필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길 땐 그 필드용 읽기/쓰기 메서드를 작성해서 두 메서드를 통해서만 필드에 접근하게 만든다.*
```
private int _low, _high;
boolean includes (int arg) {
  return arg >= _low && arg <= _high;
}
```
```
private int _low, _high;
boolean includes (int arg) {
  return arg >= getLow() && arg <= getHigh();
}
int getLow() {return _low;}
int getHigh() {return _high;}
```
##### 동기
기본적으로 변수 간접 접근 방식을 사용하면 하위클래스가 메서드에 해당 정보를 가져오는 방식을 재정의할 수 있으며, 데이터 관리(예: 속성 초기화를 생성 시점이 아닌 사용 시점으로 미루기)가 더 유연해진다는 장점이 있다.

변수 직접 접근 방식의 장점은 코드를 더욱 알아보기 쉽다는 것이다. 

필드 자체 캡슐화를 실시해야 할 가장 절실한 시점은 상위클래스 안의 필드에 접근하되 이 변수 접근을 하위클래스에서 계산된 값으로 재정의해야 할 때다. 먼저 필드를 자체 캡슐화한 후 필요할 때 읽기 메서드와 쓰기 메서드를 재정의하면 된다.
##### 방법
* 필드 읽기 메서드와 쓰기 메서드를 작성한다.
* 그 필드 참조 부분을 전부 찾아서 읽기 메서드와 쓰기 메서드로 고친다.
  * 필드 읽기 코드를 읽기 메서드 호출로 수정하고, 대입문을 쓰기 메서드 호출로 수정한다.
  * 컴파일러를 이용하면 필드명을 임시로 변경해서 쉽게 검사할 수 있다.
* 필드를 private로 만든다.
* 참조 코드를 빠짐없이 수정했는지 다시 확인한다.
* 테스트를 실시한다.
##### 예제
자체 캡슐화를 실시할 때는 생성자 안에 쓰기 메서드를 사용할 때 주의해야 한다. 대체로 객체가 생성된 후엔 속성을 변경하려고 쓰기 메서드를 사용하므로, 쓰기 메서드에 초기화 시점과 다른 기능이 추가됐을 수 있다고 전제할 때가 많다. 이럴 땐 생성자나 별도의 초기화 메서드에서 직접 접근하게 하는 것이 좋다.
<hr/>

### 데이터 값을 객체로 전환
*데이터 항목에 데이터나 기능을 추가해야 할 때는 데이터 항목을 객체로 만든다.*
##### 동기
주로 개발 초기 단계에서는 단순 정보를 간단한 데이터 항목으로 표현하는 사안에 대해 결정한다. 개발이 진행되다 보면 그런 간단한 항목이 점점 복잡해진다. 한두 항목은 객체 안에 메서드를 넣어도 되겠지만, 금세 '중복 코드'나 '잘못된 소속'이라는 코드 구린내가 풍기게 된다. 그럼 즉시 데이터 값을 객체로 전환한다. 
##### 방법
* 데이터 값을 넣을 클래스를 작성한다. 그 클래스에 원본 클래스 안의 값과 같은 타임의 final 필드를 추가한다. 그 필드를 인자로 받는 생성자와 읽기 메서드를 추가한다. 
* 컴파일한다.
* 원본 클래스에 든 필드의 타입을 새 클래스로 바꾼다.
* 원본 클래스 안의 읽기 메서드를 새 클래스의 읽기 메서드를 호출하게 수정한다.
* 그 필드가 원본 클래스 생성자 안에 사용된다면 새 클래스의 생성자를 이용해서 필드를 대입한다.
* 새 클래스의 새 인스턴스를 생성하게끔 읽기 메서드를 수정한다.
* 컴파일과 테스트를 실시한다.
* 이 단계에서 새 객체에 값을 참조로 전환을 적용해야 할 수도 있다.
<hr/>

### 값을 참조로 전환
*클래스에 같은 인스턴스가 많이 들어 있어서 이것들을 하나의 객체로 바꿔야 할 땐 그 객체를 참조 객체로 전환한다.*
##### 동기
많은 시스템에선 객체를 참조 객체와 값 객체로 분류할 수 있다. 참조 객체는 고객이나 계좌 같은 것이다. 각 객체는 현실에서의 한 객체에 대응하므로, 둘이 같은지 검사할 때는 객체 ID를 사용한다. 두 객체가 같은지 판단해야 하므로 equals 메서드와 hashCode 메서드를 재정의해야 한다.
##### 방법
* 생성자를 팩토리 메서드로 전환을 실시한다.
* 컴파일과 테스트를 실시한다.
* 참조 객체로의 접근을 담당할 객체를 정한다.
  * 이 기능은 정적 딕셔너리나 레지스트리 객체가 담당할 수도 있다.
  * 참조 객체로의 접근을 둘 이상의 객체가 담당할 수도 있다.
* 객체를 미리 생성할지 사용하기 직전에 생성할지를 정한다.
  * 객체를 미리 생성했다가 메모리에서 가져오면 사용 전에 미리 로딩되어 있는지 확인해야 한다.
* 참조 객체를 반환하게 팩토리 메서드를 수정한다.
  * 객체를 미리 생성할 경우, 존재하지 않는 객체 요청에 대한 에러 처리를 어떻게 할지 정해야 한다.
  * 팩토리 메서드가 원본 객체를 반환함을 한눈에 알 수 있게 팩토리 메서드에 메서드명 변경을 적용해야 할 수도 있다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 참조를 값으로 전환
*참조 객체가 작고 수정할 수 없고 관리하기 힘들 땐 그 참조 객체를 값 객체로 만든다.*
##### 동기
참조 객체를 사용한 작업이 복잡해지는 순간이 참조를 값으로 바꿔야 할 시점이다. 참조 객체는 어떤 식으로든 제어되어야 한다. 개발자는 컨트롤러에 항상 적절한 객체를 요청해야 한다. 메모리 연결도 엉킬 수 있다. 값 객체는 분산 시스템이나 병렬 시스템에 주로 사용된다.

값 객체는 변경할 수 없어야 한다는 주요 특성이 있다. 하나에 대한 질의를 호출하면 항상 같아야 한다. 그렇기만 하면 같은 것을 나타내는 객체가 많아도 문제가 없다. 값을 변경할 수 없다면, 어떤 객체를 수정했을 때 같은 것을 나타내는 다른 객체들도 전부 바뀌는지 확인해야 하는데, 그렇게 하기란 그나마 가장 쉽게 할 수 있는 것이 참조 객체로 만드는 것일 정도로 너무 힘든 일이다.

'변경불가'의 뜻을 명확히 해야 한다. 
##### 방법
* 전환할 객체가 변경불가인지 변경 가능인지 검사한다.
  * 전환할 객체가 변경불가가 아니면, 변경불가가 될 때까지 쓰기 메서드 제거를 실시한다.
  * 전환할 객체가 변경불가이면 이 리팩토링은 관둔다.
* equals 메서드와 hash 메서드를 작성한다.
* 컴파일과 테스트를 실시한다.
* 팩토리 메서드를 삭제하고 생성자를 public으로 만들어야 좋을지 생각해본다.
<hr/>

### 배열을 객체로 전환
*배열을 구성하는 특정 원소가 별의별 의미를 지닐 땐 그 배열을 각 원소마다 필드가 하나씩 든 객체로 전환한다.*
```
String[] row = new String[3];
row [0] = "Liverpool";
row [1] = "15";
```
```
Performance row = new Performance();
row.setName("Liverpool");
row.setWins("15");
```
##### 동기
배열은 데이터 정리에 흔히 사용되는 구조다. 그러나 배열은 비슷한 객체들의 컬렉션을 일정순서로 담는 용도로만 사용해야 한다. 객체를 사용하면 필드명과 메서드명을 사용하여 이러한 정보를 전달할 수 있으므로 기억하거나 주석을 갱신할 필요가 없다. 이런 정보를 캡슐화하고 메서드 이동을 실시하여 객체에 기능을 추가할 수도 있다. 
##### 방법
* 배열 안의 정보를 표현할 새 클래스를 작성한다. 그 클래스 안에 배열을 저장할 public 필드를 하나 작성한다.
* 배열 참조 부분을 전부 새 클래스 참조로 수정한다.
* 컴파일과 테스트를 실시한다.
* 배열의 각 원소마다 참조 코드에 사용할 읽기 메서드를 하나씩 넣는다. 배열 원소의 용도를 따서 읽기 메서드 이름을 정한다. 참조 부분을 읽기 메서드 호출로 전부 수정한다. 하나의 수정을 마칠 때마다 테스트를 실시한다.
* 배열 참조 부분을 전부 메서드로 교체했으면 배열을 private로 만든다.
* 컴파일한다.
* 클래스 안에 배열의 각 원소에 대응되는 하나의 필드를 생성한 후, 그 필드를 사용하게끔 읽기/쓰기 메서드를 수정한다.
* 각 원소에 대한 수정을 마칠 때마다 컴파일과 테스트를 실시한다.
* 모든 원소를 필드로 교체했으면 배열을 삭제한다.
<hr/>

### 관측 데이터 복제
*도메인 데이터는 GUI 컨트롤 안에서만 사용 가능한데, 도메인 메서드가 그 데이터에 접근해야 할 땐 그 데이터를 도메인 객체로 복사하고, 양측의 데이터를 동기화하는 관측 인터페이스 observer를 작성한다.*
##### 동기
계층구조가 체계적인 시스템은 비즈니스 로직 처리 코드와 사용자 인터페이스 처리 코드가 분리되어 있다. 거기엔 몇가지 이유가 있다.
* 비슷한 비즈니스 로직을 여러 인터페이스가 처리해야 하는 경우라서
* 비즈니스 로직까지 처리하려면 사용자 인터페이스가 너무 복잡해지니까
* GUI와 분리된 도메인 객체가 더욱 유지보수하기 쉬우니까
* 두 부분을 서로 다른 개발자가 다루게 할 수 있으니까
기능은 간단히 분리할 수 있어도 데이터는 분리하기 어려울 때가 많다. 도메인 모델에 있는 데이터와 같은 의미를 지닌 데이터를 GUI 컨트롤에 넣어야 하기 때문이다. 모델-뷰-컨트롤러(MVC) 패턴부터 시작해서 그 이후로, 사용자 인터페이스 프레임워크는 이러한 데이터를 제공하고 모든 데이터의 동기화를 유지하는 다층 시스템을 사용했다.

비즈니스 로직이 사용자 인터페이스 안에 들어 있는 2계층 방식으로 개발된 코드가 있다면 인터페이스에서 기능을 분리해야 한다. 대부분은 메서드를 쪼개서 옮기는 작업이다. 하지만 데이터는 그저 옮기기만 해선 안 된고 복제하고 동기화 기능까지 작성해야 한다.
##### 방법
* 표현 클래스를 도메인 클래스의 관측 인터페이스로 만든다.
  * 도메인 클래스가 없으면 하나 작성한다.
  * 표현 클래스에 도메인 클래스로의 연결 코드가 없으면 표현 클래스의 필드에 도메인 클래스를 대입한다.
* GUI 클래스 안의 도메인 데이터를 대상으로 필드 자체 캡슐화를 실시한다.
* 컴파일과 테스트를 실시한다.
* 이벤트 핸들러 메서드 안에 쓰기 메서드 호출 코드를 추가한다. 이 쓰기 메서드는 직접 접근 방식으로 컴포넌트를 현재 값으로 수정한다.
  * 현재 값에 따라 컴포넌트 값을 수정하는 메서드를 이벤트 핸들러 안에 넣는다. 물론 이 단계는 컴포넌트 값을 현재 값으로 설정하는 것뿐이니 필요가 없지만, 쓰기 메서드를 사용하면 어떤 기능이든 실행할 수 있다.
  * 이렇게 수정할 때 읽기 메서드를 사용하지 말고 컴포넌트에 직접 접근하자. 나중에 읽기 메서드는 도메인에서 값을 가져오는 데 쓰이는데, 그 값은 쓰기 메서드 실행 전까진 변하지 않는다.
  * 테스트 코드로 이벤트 처리 절차를 확인한다.
* 컴파일과 테스트를 실시한다.
* 도메인 클래스 안에 데이터와 읽기/쓰기 메서드를 정의한다.
  * 도메인에 있는 쓰기 메서드가 반드시 관측 인터페이스 패턴(기존에 '옵저버 패턴'으로 알려짐)의 통지 절차를 시작하게 만든다.
  * 도메인 클래스 안의 데이터 타입을 표현 클래스 안의 데이터 타입과 같게 한다. 주로 문자열 타입이다. 이 데이터 타입을 추가 리팩토링 기법을 실시할 때 변환한다.
* 쓰기 메서드가 도메인 필드에 쓰도록 참조를 수정한다.
* 관측 인터페이스의 update 메서드를 도메인 필드에서 GUI 컨트롤로 데이터를 복사하게 수정한다.
* 컴파일과 테스트를 실시한다.
##### 예제
비교적 오래된 AWT 패키지의 클래스를 사용중이라면 Swing을 사용하여 코드를 더 보기 좋게 만들고 협응성도 높일 수 이싿. 협응성이란, 코드 각 부분이 서로 매끄럽게 관계하며 기능하는 성질을 말한다.
###### 이벤트 리스너 사용
관측 데이터 복제기법은 관측 인터페이스 Observer나 관측 클래스 Ibservable 대신 이벤트 리스너를 사용할 때도 적용된다. 이때 도메인 모델 안에 리스너와 이벤트를 작성해야 한다. 단, 종속성이 별로 문제되지 않을 땐 AWT 패키지의 클래스를 사용해도 된다. 도메인 객체는 관측 클래스 안에서와 같은 방식으로 리스너를 등록하고, 변경이 있을 때 리스너에 이벤트를 전송해야 한다.
<hr/>

### 클래스의 단방향 연결을 양방향으로 전환
*두 클래스가 서로의 기능을 사용해야 하는데 한 방향으로만 연결되어 있을 땐 역 포인터를 추가하고 두 클래스를 모두 업데이트할 수 있게 접근 한정자를 수정한다.*
##### 동기
애초에 두 클래스를 설정할 때 한 클래스가 다른 클래스를 참조하게 해놓은 경우가 있을 수 있다. 나중에 참조되는 클래스를 사용하는 부분에서 그 클래스를 참조하는 객체들을 가져와야 할 수도 있다. 즉, 포인터를 역방향으로 참조해야 한다. 포인터는 단방향 연결이라서 이런 식의 역방향 참조는 불가능하다. 다른 경로를 찾아서 해결할 수 있을 때도 있다. 이렇게 하면 계산에 비요잉 들긴 해도 합리적이며, 이 기능을 사용하는 메서드를 참조되는 클래스에 넣을 수 있다. 하지만 이게 쉽지 않을 때도 있으므로 양방향 참조(때에 따라 '역 포인터'라고도 부름)를 설정해야 한다. 역 포인터에 익숙하지 않을 땐 포인터 사용이 뒤죽박죽되기 쉽지만, 익숙해지면 별로 복잡하지 않다.

이 방법은 까다로운 과정이 많아 익숙해질 때까진 반드시 각종 테스트를 실시해야 한다. 읽기/쓰기 메서드는 실수할 위험이 거의 없어서 나는 테스트 코드를 넣는 일이 거의 없는데, 이 리팩토링 기법은 극소수의 예외로 반드시 테스트를 추가해야 한다.

이 리팩토링 기법은 역 포인터를 사용해서 양방향 연결을 구현한다. 연결 객체 등의 다른 방법을 사용하려면 다른 리팩토링 기법을 이용해야 한다.
##### 방법
* 역 포인터 참조용 필드를 추가한다.
* 연결 제어 기능을 어느 클래스에 넣을지 정한다.
* 연결 제어 기능이 없는 클래스 안에 헬퍼 메서드를 작성하고, 그 메서드에 제한된 용도가 분명히 드러나는 이름을 붙인다.
* 기존 변경 메서드가 연결 제어 클래스에 들어 있으면 역 포인터를 업데이트하게 변경 메서드를 수정한다.
* 기존 변경 메서드가 연결 제어 클래스에 들어 있으면 제어 클래스 안에 제어 메서드를 작성하고 기존 변경 메서드가 그 메서드를 호출하게 한다.
##### 예제
* 연결을 제어할 클래스를 정해야 한다. 연결을 조작하는 로직을 전부 한 곳에 두기 위해 연결 제어 로직은 하나의 클래스에 넣는 것이 좋다. 결정하는 과정은 다음과 같다.
  * 두 객체가 모두 참조 객체이고 연결이 일대다이면 참조가 하나 들어 있는 객체를 제어 객체로 정한다.
  * 한 객체가 다른 객체에 포함될 때는 포함되는 객체를 제어 객체로 정한다.
  * 두 객체가 모두 참조 객체이고 연결이 다대다이면, 어느 클래스를 연결 제어 객체로 정해도 상관없다.
* null 인자는 꼭 검새해야 한다.
* 기본 패턴은 같다. 우선 다른 객체에 이 객체의 포인터를 제거하도록 전달하고, 이 객체의 포인터를 새 객체에 할당한 후 이 객체로의 포인터를 추가하게 새 객체에 명령해야 한다.
<hr/>

### 클래스의 양방향 연결을 단방향으로 전환
*두 클래스가 양방향으로 연결되어 있는데 한 클래스가 다른 클래스의 기능을 더 이상 사용하지 않게 됐을 땐 불필요한 방향의 연결을 끊는다.*
##### 동기
양방향 연결은 쓸모가 많지만 대가가 따른다. 즉, 양방향 연결을 유지하고 객체가 적절히 생성되고 제거되는지 확인하는 복잡함이 더해진다. 양방향 연결이 익숙하지 않은 대부분의 프로그래머는 에러를 발생시킨다.

양방향 연결이 많으면 좀비 객체가 발생하기도 쉽다. 좀비 객체란 참조가 삭제되지 않아 제거되어야 함에도 남아서 떠도는 객체를 뜻한다.

양방향 연결로 인해 두 클래스는 서로 종속된다. 한 클래스를 수정하면 다른 클래스도 변경된다. 종속성이 많으면 시스템의 결합력이 강해져서 사소한 수정에도 예기치 못한 각종 문제가 발생한다.

그러니 양방향 연결은 꼭 필요할 때만 사용해야 한다. 양방향 연결이 더 이상 쓸모없다고 판단되면 불필요한 말단의 연결을 차단한다.
##### 방법
* 삭제하려는 포인터가 저장된 필드를 읽는 모든 부분을 검사해서 삭제해도 되는지 파악한다.
  * 필드를 직접 읽는 메서드와 그 메서드를 호출하는 다른 메서드도 살펴본다.
  * 포인터를 사용하지 않고 다른 객체를 알아내는 것이 가능한지 생각해보고, 가능하다면 속성 읽기 메서드에 알고리즘 전환을 실시해서 참조 코드가 포인터 없이 속성 읽기 메서드를 사용할 수 있게 한다.
  * 포인터 필드를 사용하는 모든 메서드에 그 객체를 매개변수로 전달하는 방법을 고려한다.
* 참조 코드가 속성 읽기 메서드를 사용해야 한다면 속성 읽기 메서드에 필드 자체 캡슐화를 적용하고 알고리즘 전환을 적용한 후 테스트를 실시한다.
* 참조 코드에 읽기 메서드 호출을 넣을 필요가 없다면, 각 필드 사용 부분을 찾아서 필드 안의 객체를 다른 방법으로 가져오게끔 수정한다. 각 수정 후에 테스트를 실시한다.
* 필드 안의 속성 읽기 메서드를 모두 삭제했으면 필드 업데이트 코드 전부와 필드를 삭제한다.
  * 필드에 값을 할당하는 부분이 여러 군데 있다면 필드 자체 캡슐화를 실시해서 그 모든 부분이 한 개의 속성 쓰기 메서드를 사용하게 한다. 테스트를 실시한 후 속성 쓰기 메서드를 빈 메서드로 만들고 다시 테스트한다. 오류가 없으면 필드, 속성 읽기 메서드, 모든 속성 쓰기 메서드 호출 코드를 삭제한다.
* 컴파일과 테스트를 실시한다.
##### 예제
* 이 리팩토링에서는 가능한지 여부를 확인하는 것이 제일 어렵다.
* 읽기/쓰기 메서드를 그대로 두면, 코드 구현부의 연결은 단방향이 되지만 인터페이스 안의 연결은 양방향성이 유지된다. 역 포인터만 제거되고 두 클래스의 상호 종속성은 그대로인 셈이다.
* 하나를 수정할 때마다 테스트를 실시한다.
<hr/>

### 마법 숫자를 기호 상수로 전환
*특수 의미를 지닌 리터럴 숫자가 있을 땐 의미를 살린 이름의 상수를 작성한 후 리터럴 숫자를 그 상수로 교체한다.*
```
double potentialEnergy(double mass, double height) {
  return mass * 9.81 * height;
}
```
```
double potentialEnergy(double mass, double height) {
  return mass* GRAVITATIONAL_CONSTANT * height;
}
static final double GRAVITATIONAL_CONSTANT = 9.81;
```
##### 동기
마법 숫자(magic number)는 전산 업계의 가장 오래된 인습 중 하나다. 마법 숫자는 특수한 값을 갖는 숫자를 일컫는 용어로, 그 의미는 분명하지 않다. 마법 숫자는 여러 곳에서 논리적으로 같은 숫자를 참조해야 할 때 특히 문제가 많다. 마법 숫자가 혹시라도 변경될 가능성이 있다면 끔찍한 일이다. 변경하지 않더라도 코드에서 어떻게 처리되고 있는지 알아내기 힘들다.

대부분의 언어는 상수 선언 기능이 있다. 상수를 사용하면 단점이나 부작용 없이 성능이 향상되며 가독성이 엄청나게 향상된다.

이 리팩토링 기법을 실시하기 전에는 언제나 다른 방법이 있는지 살펴봐야 한다. 마법 숫자가 어떤 식으로 사용되는지도 본다. 마법 숫자가 분류 부호라면 분류 부호를 클래스로 전환기법 적용을 고려하고, 마법 숫자가 배열의 길이라면 anArray.length를 사용해서 그 배열 원소 전체에 대해 루프를 실행한다.
##### 방법
* 상수를 선언하고 그 상수에 마법 숫자의 값을 할당한다.
* 마법 숫자가 사용되는 부분을 모두 찾아낸다.
* 마법 숫자가 상수의 용도와 맞는지 살펴보고, 그렇다면 마법 숫자를 상수로 교체한다.
* 컴파일한다.
* 모든 마법 숫자를 상수로 고쳤으면 테스트를 실시한다. 이때 모든 기능이 수정 전과 동일하게 작동해야 한다.
  * 좋은 테스트 방법은 상수를 쉽게 수정할 수 있는지 살펴보는 것이다. 몇몇 예상 결과를 변경해도 새 값과 일치해야 한다. 항상 수정할 수 있는 건 아니지만, 작동할 경우엔 괜찮은 편법이다.
<hr/>
 
 ### 필드 캡슐화
 
