# 데이터 체계화
### 필드 자체 캡슐화
*필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길 땐 그 필드용 읽기/쓰기 메서드를 작성해서 두 메서드를 통해서만 필드에 접근하게 만든다.*
```
private int _low, _high;
boolean includes (int arg) {
  return arg >= _low && arg <= _high;
}
```
```
private int _low, _high;
boolean includes (int arg) {
  return arg >= getLow() && arg <= getHigh();
}
int getLow() {return _low;}
int getHigh() {return _high;}
```
##### 동기
기본적으로 변수 간접 접근 방식을 사용하면 하위클래스가 메서드에 해당 정보를 가져오는 방식을 재정의할 수 있으며, 데이터 관리(예: 속성 초기화를 생성 시점이 아닌 사용 시점으로 미루기)가 더 유연해진다는 장점이 있다.

변수 직접 접근 방식의 장점은 코드를 더욱 알아보기 쉽다는 것이다. 

필드 자체 캡슐화를 실시해야 할 가장 절실한 시점은 상위클래스 안의 필드에 접근하되 이 변수 접근을 하위클래스에서 계산된 값으로 재정의해야 할 때다. 먼저 필드를 자체 캡슐화한 후 필요할 때 읽기 메서드와 쓰기 메서드를 재정의하면 된다.
##### 방법
* 필드 읽기 메서드와 쓰기 메서드를 작성한다.
* 그 필드 참조 부분을 전부 찾아서 읽기 메서드와 쓰기 메서드로 고친다.
  * 필드 읽기 코드를 읽기 메서드 호출로 수정하고, 대입문을 쓰기 메서드 호출로 수정한다.
  * 컴파일러를 이용하면 필드명을 임시로 변경해서 쉽게 검사할 수 있다.
* 필드를 private로 만든다.
* 참조 코드를 빠짐없이 수정했는지 다시 확인한다.
* 테스트를 실시한다.
##### 예제
자체 캡슐화를 실시할 때는 생성자 안에 쓰기 메서드를 사용할 때 주의해야 한다. 대체로 객체가 생성된 후엔 속성을 변경하려고 쓰기 메서드를 사용하므로, 쓰기 메서드에 초기화 시점과 다른 기능이 추가됐을 수 있다고 전제할 때가 많다. 이럴 땐 생성자나 별도의 초기화 메서드에서 직접 접근하게 하는 것이 좋다.
<hr/>

### 데이터 값을 객체로 전환
*데이터 항목에 데이터나 기능을 추가해야 할 때는 데이터 항목을 객체로 만든다.*
##### 동기
주로 개발 초기 단계에서는 단순 정보를 간단한 데이터 항목으로 표현하는 사안에 대해 결정한다. 개발이 진행되다 보면 그런 간단한 항목이 점점 복잡해진다. 한두 항목은 객체 안에 메서드를 넣어도 되겠지만, 금세 '중복 코드'나 '잘못된 소속'이라는 코드 구린내가 풍기게 된다. 그럼 즉시 데이터 값을 객체로 전환한다. 
##### 방법
* 데이터 값을 넣을 클래스를 작성한다. 그 클래스에 원본 클래스 안의 값과 같은 타임의 final 필드를 추가한다. 그 필드를 인자로 받는 생성자와 읽기 메서드를 추가한다. 
* 컴파일한다.
* 원본 클래스에 든 필드의 타입을 새 클래스로 바꾼다.
* 원본 클래스 안의 읽기 메서드를 새 클래스의 읽기 메서드를 호출하게 수정한다.
* 그 필드가 원본 클래스 생성자 안에 사용된다면 새 클래스의 생성자를 이용해서 필드를 대입한다.
* 새 클래스의 새 인스턴스를 생성하게끔 읽기 메서드를 수정한다.
* 컴파일과 테스트를 실시한다.
* 이 단계에서 새 객체에 값을 참조로 전환을 적용해야 할 수도 있다.
<hr/>

### 값을 참조로 전환
*클래스에 같은 인스턴스가 많이 들어 있어서 이것들을 하나의 객체로 바꿔야 할 땐 그 객체를 참조 객체로 전환한다.*
##### 동기
많은 시스템에선 객체를 참조 객체와 값 객체로 분류할 수 있다. 참조 객체는 고객이나 계좌 같은 것이다. 각 객체는 현실에서의 한 객체에 대응하므로, 둘이 같은지 검사할 때는 객체 ID를 사용한다. 두 객체가 같은지 판단해야 하므로 equals 메서드와 hashCode 메서드를 재정의해야 한다.
##### 방법
* 생성자를 팩토리 메서드로 전환을 실시한다.
* 컴파일과 테스트를 실시한다.
* 참조 객체로의 접근을 담당할 객체를 정한다.
  * 이 기능은 정적 딕셔너리나 레지스트리 객체가 담당할 수도 있다.
  * 참조 객체로의 접근을 둘 이상의 객체가 담당할 수도 있다.
* 객체를 미리 생성할지 사용하기 직전에 생성할지를 정한다.
  * 객체를 미리 생성했다가 메모리에서 가져오면 사용 전에 미리 로딩되어 있는지 확인해야 한다.
* 참조 객체를 반환하게 팩토리 메서드를 수정한다.
  * 객체를 미리 생성할 경우, 존재하지 않는 객체 요청에 대한 에러 처리를 어떻게 할지 정해야 한다.
  * 팩토리 메서드가 원본 객체를 반환함을 한눈에 알 수 있게 팩토리 메서드에 메서드명 변경을 적용해야 할 수도 있다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 참조를 값으로 전환
*참조 객체가 작고 수정할 수 없고 관리하기 힘들 땐 그 참조 객체를 값 객체로 만든다.*
##### 동기
참조 객체를 사용한 작업이 복잡해지는 순간이 참조를 값으로 바꿔야 할 시점이다. 참조 객체는 어떤 식으로든 제어되어야 한다. 개발자는 컨트롤러에 항상 적절한 객체를 요청해야 한다. 메모리 연결도 엉킬 수 있다. 값 객체는 분산 시스템이나 병렬 시스템에 주로 사용된다.

값 객체는 변경할 수 없어야 한다는 주요 특성이 있다. 하나에 대한 질의를 호출하면 항상 같아야 한다. 그렇기만 하면 같은 것을 나타내는 객체가 많아도 문제가 없다. 값을 변경할 수 없다면, 어떤 객체를 수정했을 때 같은 것을 나타내는 다른 객체들도 전부 바뀌는지 확인해야 하는데, 그렇게 하기란 그나마 가장 쉽게 할 수 있는 것이 참조 객체로 만드는 것일 정도로 너무 힘든 일이다.

'변경불가'의 뜻을 명확히 해야 한다. 
##### 방법
* 전환할 객체가 변경불가인지 변경 가능인지 검사한다.
  * 전환할 객체가 변경불가가 아니면, 변경불가가 될 때까지 쓰기 메서드 제거를 실시한다.
  * 전환할 객체가 변경불가이면 이 리팩토링은 관둔다.
* equals 메서드와 hash 메서드를 작성한다.
* 컴파일과 테스트를 실시한다.
* 팩토리 메서드를 삭제하고 생성자를 public으로 만들어야 좋을지 생각해본다.
<hr/>

### 배열을 객체로 전환
*배열을 구성하는 특정 원소가 별의별 의미를 지닐 땐 그 배열을 각 원소마다 필드가 하나씩 든 객체로 전환한다.*
```
String[] row = new String[3];
row [0] = "Liverpool";
row [1] = "15";
```
```
Performance row = new Performance();
row.setName("Liverpool");
row.setWins("15");
```
##### 동기
배열은 데이터 정리에 흔히 사용되는 구조다. 그러나 배열은 비슷한 객체들의 컬렉션을 일정순서로 담는 용도로만 사용해야 한다. 객체를 사용하면 필드명과 메서드명을 사용하여 이러한 정보를 전달할 수 있으므로 기억하거나 주석을 갱신할 필요가 없다. 이런 정보를 캡슐화하고 메서드 이동을 실시하여 객체에 기능을 추가할 수도 있다. 
##### 방법
* 배열 안의 정보를 표현할 새 클래스를 작성한다. 그 클래스 안에 배열을 저장할 public 필드를 하나 작성한다.
* 배열 참조 부분을 전부 새 클래스 참조로 수정한다.
* 컴파일과 테스트를 실시한다.
* 배열의 각 원소마다 참조 코드에 사용할 읽기 메서드를 하나씩 넣는다. 배열 원소의 용도를 따서 읽기 메서드 이름을 정한다. 참조 부분을 읽기 메서드 호출로 전부 수정한다. 하나의 수정을 마칠 때마다 테스트를 실시한다.
* 배열 참조 부분을 전부 메서드로 교체했으면 배열을 private로 만든다.
* 컴파일한다.
* 클래스 안에 배열의 각 원소에 대응되는 하나의 필드를 생성한 후, 그 필드를 사용하게끔 읽기/쓰기 메서드를 수정한다.
* 각 원소에 대한 수정을 마칠 때마다 컴파일과 테스트를 실시한다.
* 모든 원소를 필드로 교체했으면 배열을 삭제한다.
<hr/>

### 관측 데이터 복제
*도메인 데이터는 GUI 컨트롤 안에서만 사용 가능한데, 도메인 메서드가 그 데이터에 접근해야 할 땐 그 데이터를 도메인 객체로 복사하고, 양측의 데이터를 동기화하는 관측 인터페이스 observer를 작성한다.*
##### 동기
계층구조가 체계적인 시스템은 비즈니스 로직 처리 코드와 사용자 인터페이스 처리 코드가 분리되어 있다. 거기엔 몇가지 이유가 있다.
* 비슷한 비즈니스 로직을 여러 인터페이스가 처리해야 하는 경우라서
* 비즈니스 로직까지 처리하려면 사용자 인터페이스가 너무 복잡해지니까
* GUI와 분리된 도메인 객체가 더욱 유지보수하기 쉬우니까
* 두 부분을 서로 다른 개발자가 다루게 할 수 있으니까
기능은 간단히 분리할 수 있어도 데이터는 분리하기 어려울 때가 많다. 도메인 모델에 있는 데이터와 같은 의미를 지닌 데이터를 GUI 컨트롤에 넣어야 하기 때문이다. 모델-뷰-컨트롤러(MVC) 패턴부터 시작해서 그 이후로, 사용자 인터페이스 프레임워크는 이러한 데이터를 제공하고 모든 데이터의 동기화를 유지하는 다층 시스템을 사용했다.

비즈니스 로직이 사용자 인터페이스 안에 들어 있는 2계층 방식으로 개발된 코드가 있다면 인터페이스에서 기능을 분리해야 한다. 대부분은 메서드를 쪼개서 옮기는 작업이다. 하지만 데이터는 그저 옮기기만 해선 안 된고 복제하고 동기화 기능까지 작성해야 한다.
##### 방법
* 표현 클래스를 도메인 클래스의 관측 인터페이스로 만든다.
  * 도메인 클래스가 없으면 하나 작성한다.
  * 표현 클래스에 도메인 클래스로의 연결 코드가 없으면 표현 클래스의 필드에 도메인 클래스를 대입한다.
* GUI 클래스 안의 도메인 데이터를 대상으로 필드 자체 캡슐화를 실시한다.
* 컴파일과 테스트를 실시한다.
* 이벤트 핸들러 메서드 안에 쓰기 메서드 호출 코드를 추가한다. 이 쓰기 메서드는 직접 접근 방식으로 컴포넌트를 현재 값으로 수정한다.
  * 현재 값에 따라 컴포넌트 값을 수정하는 메서드를 이벤트 핸들러 안에 넣는다. 물론 이 단계는 컴포넌트 값을 현재 값으로 설정하는 것뿐이니 필요가 없지만, 쓰기 메서드를 사용하면 어떤 기능이든 실행할 수 있다.
  * 이렇게 수정할 때 읽기 메서드를 사용하지 말고 컴포넌트에 직접 접근하자. 나중에 읽기 메서드는 도메인에서 값을 가져오는 데 쓰이는데, 그 값은 쓰기 메서드 실행 전까진 변하지 않는다.
  * 테스트 코드로 이벤트 처리 절차를 확인한다.
* 컴파일과 테스트를 실시한다.
* 도메인 클래스 안에 데이터와 읽기/쓰기 메서드를 정의한다.
  * 도메인에 있는 쓰기 메서드가 반드시 관측 인터페이스 패턴(기존에 '옵저버 패턴'으로 알려짐)의 통지 절차를 시작하게 만든다.
  * 도메인 클래스 안의 데이터 타입을 표현 클래스 안의 데이터 타입과 같게 한다. 주로 문자열 타입이다. 이 데이터 타입을 추가 리팩토링 기법을 실시할 때 변환한다.
* 쓰기 메서드가 도메인 필드에 쓰도록 참조를 수정한다.
* 관측 인터페이스의 update 메서드를 도메인 필드에서 GUI 컨트롤로 데이터를 복사하게 수정한다.
* 컴파일과 테스트를 실시한다.
##### 예제
비교적 오래된 AWT 패키지의 클래스를 사용중이라면 Swing을 사용하여 코드를 더 보기 좋게 만들고 협응성도 높일 수 이싿. 협응성이란, 코드 각 부분이 서로 매끄럽게 관계하며 기능하는 성질을 말한다.
###### 이벤트 리스너 사용
관측 데이터 복제기법은 관측 인터페이스 Observer나 관측 클래스 Ibservable 대신 이벤트 리스너를 사용할 때도 적용된다. 이때 도메인 모델 안에 리스너와 이벤트를 작성해야 한다. 단, 종속성이 별로 문제되지 않을 땐 AWT 패키지의 클래스를 사용해도 된다. 도메인 객체는 관측 클래스 안에서와 같은 방식으로 리스너를 등록하고, 변경이 있을 때 리스너에 이벤트를 전송해야 한다.
<hr/>

### 클래스의 단방향 연결을 양방향으로 전환
*두 클래스가 서로의 기능을 사용해야 하는데 한 방향으로만 연결되어 있을 땐 역 포인터를 추가하고 두 클래스를 모두 업데이트할 수 있게 접근 한정자를 수정한다.*
##### 동기
애초에 두 클래스를 설정할 때 한 클래스가 다른 클래스를 참조하게 해놓은 경우가 있을 수 있다. 나중에 참조되는 클래스를 사용하는 부분에서 그 클래스를 참조하는 객체들을 가져와야 할 수도 있다. 즉, 포인터를 역방향으로 참조해야 한다. 포인터는 단방향 연결이라서 이런 식의 역방향 참조는 불가능하다. 다른 경로를 찾아서 해결할 수 있을 때도 있다. 이렇게 하면 계산에 비요잉 들긴 해도 합리적이며, 이 기능을 사용하는 메서드를 참조되는 클래스에 넣을 수 있다. 하지만 이게 쉽지 않을 때도 있으므로 양방향 참조(때에 따라 '역 포인터'라고도 부름)를 설정해야 한다. 역 포인터에 익숙하지 않을 땐 포인터 사용이 뒤죽박죽되기 쉽지만, 익숙해지면 별로 복잡하지 않다.

이 방법은 까다로운 과정이 많아 익숙해질 때까진 반드시 각종 테스트를 실시해야 한다. 읽기/쓰기 메서드는 실수할 위험이 거의 없어서 나는 테스트 코드를 넣는 일이 거의 없는데, 이 리팩토링 기법은 극소수의 예외로 반드시 테스트를 추가해야 한다.

이 리팩토링 기법은 역 포인터를 사용해서 양방향 연결을 구현한다. 연결 객체 등의 다른 방법을 사용하려면 다른 리팩토링 기법을 이용해야 한다.
##### 방법
* 역 포인터 참조용 필드를 추가한다.
* 연결 제어 기능을 어느 클래스에 넣을지 정한다.
* 연결 제어 기능이 없는 클래스 안에 헬퍼 메서드를 작성하고, 그 메서드에 제한된 용도가 분명히 드러나는 이름을 붙인다.
* 기존 변경 메서드가 연결 제어 클래스에 들어 있으면 역 포인터를 업데이트하게 변경 메서드를 수정한다.
* 기존 변경 메서드가 연결 제어 클래스에 들어 있으면 제어 클래스 안에 제어 메서드를 작성하고 기존 변경 메서드가 그 메서드를 호출하게 한다.
##### 예제
* 연결을 제어할 클래스를 정해야 한다. 연결을 조작하는 로직을 전부 한 곳에 두기 위해 연결 제어 로직은 하나의 클래스에 넣는 것이 좋다. 결정하는 과정은 다음과 같다.
  * 두 객체가 모두 참조 객체이고 연결이 일대다이면 참조가 하나 들어 있는 객체를 제어 객체로 정한다.
  * 한 객체가 다른 객체에 포함될 때는 포함되는 객체를 제어 객체로 정한다.
  * 두 객체가 모두 참조 객체이고 연결이 다대다이면, 어느 클래스를 연결 제어 객체로 정해도 상관없다.
* null 인자는 꼭 검새해야 한다.
* 기본 패턴은 같다. 우선 다른 객체에 이 객체의 포인터를 제거하도록 전달하고, 이 객체의 포인터를 새 객체에 할당한 후 이 객체로의 포인터를 추가하게 새 객체에 명령해야 한다.
<hr/>

### 클래스의 양방향 연결을 단방향으로 전환
*두 클래스가 양방향으로 연결되어 있는데 한 클래스가 다른 클래스의 기능을 더 이상 사용하지 않게 됐을 땐 불필요한 방향의 연결을 끊는다.*
##### 동기
양방향 연결은 쓸모가 많지만 대가가 따른다. 즉, 양방향 연결을 유지하고 객체가 적절히 생성되고 제거되는지 확인하는 복잡함이 더해진다. 양방향 연결이 익숙하지 않은 대부분의 프로그래머는 에러를 발생시킨다.

양방향 연결이 많으면 좀비 객체가 발생하기도 쉽다. 좀비 객체란 참조가 삭제되지 않아 제거되어야 함에도 남아서 떠도는 객체를 뜻한다.

양방향 연결로 인해 두 클래스는 서로 종속된다. 한 클래스를 수정하면 다른 클래스도 변경된다. 종속성이 많으면 시스템의 결합력이 강해져서 사소한 수정에도 예기치 못한 각종 문제가 발생한다.

그러니 양방향 연결은 꼭 필요할 때만 사용해야 한다. 양방향 연결이 더 이상 쓸모없다고 판단되면 불필요한 말단의 연결을 차단한다.
##### 방법
* 삭제하려는 포인터가 저장된 필드를 읽는 모든 부분을 검사해서 삭제해도 되는지 파악한다.
  * 필드를 직접 읽는 메서드와 그 메서드를 호출하는 다른 메서드도 살펴본다.
  * 포인터를 사용하지 않고 다른 객체를 알아내는 것이 가능한지 생각해보고, 가능하다면 속성 읽기 메서드에 알고리즘 전환을 실시해서 참조 코드가 포인터 없이 속성 읽기 메서드를 사용할 수 있게 한다.
  * 포인터 필드를 사용하는 모든 메서드에 그 객체를 매개변수로 전달하는 방법을 고려한다.
* 참조 코드가 속성 읽기 메서드를 사용해야 한다면 속성 읽기 메서드에 필드 자체 캡슐화를 적용하고 알고리즘 전환을 적용한 후 테스트를 실시한다.
* 참조 코드에 읽기 메서드 호출을 넣을 필요가 없다면, 각 필드 사용 부분을 찾아서 필드 안의 객체를 다른 방법으로 가져오게끔 수정한다. 각 수정 후에 테스트를 실시한다.
* 필드 안의 속성 읽기 메서드를 모두 삭제했으면 필드 업데이트 코드 전부와 필드를 삭제한다.
  * 필드에 값을 할당하는 부분이 여러 군데 있다면 필드 자체 캡슐화를 실시해서 그 모든 부분이 한 개의 속성 쓰기 메서드를 사용하게 한다. 테스트를 실시한 후 속성 쓰기 메서드를 빈 메서드로 만들고 다시 테스트한다. 오류가 없으면 필드, 속성 읽기 메서드, 모든 속성 쓰기 메서드 호출 코드를 삭제한다.
* 컴파일과 테스트를 실시한다.
##### 예제
* 이 리팩토링에서는 가능한지 여부를 확인하는 것이 제일 어렵다.
* 읽기/쓰기 메서드를 그대로 두면, 코드 구현부의 연결은 단방향이 되지만 인터페이스 안의 연결은 양방향성이 유지된다. 역 포인터만 제거되고 두 클래스의 상호 종속성은 그대로인 셈이다.
* 하나를 수정할 때마다 테스트를 실시한다.
<hr/>

### 마법 숫자를 기호 상수로 전환
*특수 의미를 지닌 리터럴 숫자가 있을 땐 의미를 살린 이름의 상수를 작성한 후 리터럴 숫자를 그 상수로 교체한다.*
```
double potentialEnergy(double mass, double height) {
  return mass * 9.81 * height;
}
```
```
double potentialEnergy(double mass, double height) {
  return mass* GRAVITATIONAL_CONSTANT * height;
}
static final double GRAVITATIONAL_CONSTANT = 9.81;
```
##### 동기
마법 숫자(magic number)는 전산 업계의 가장 오래된 인습 중 하나다. 마법 숫자는 특수한 값을 갖는 숫자를 일컫는 용어로, 그 의미는 분명하지 않다. 마법 숫자는 여러 곳에서 논리적으로 같은 숫자를 참조해야 할 때 특히 문제가 많다. 마법 숫자가 혹시라도 변경될 가능성이 있다면 끔찍한 일이다. 변경하지 않더라도 코드에서 어떻게 처리되고 있는지 알아내기 힘들다.

대부분의 언어는 상수 선언 기능이 있다. 상수를 사용하면 단점이나 부작용 없이 성능이 향상되며 가독성이 엄청나게 향상된다.

이 리팩토링 기법을 실시하기 전에는 언제나 다른 방법이 있는지 살펴봐야 한다. 마법 숫자가 어떤 식으로 사용되는지도 본다. 마법 숫자가 분류 부호라면 분류 부호를 클래스로 전환기법 적용을 고려하고, 마법 숫자가 배열의 길이라면 anArray.length를 사용해서 그 배열 원소 전체에 대해 루프를 실행한다.
##### 방법
* 상수를 선언하고 그 상수에 마법 숫자의 값을 할당한다.
* 마법 숫자가 사용되는 부분을 모두 찾아낸다.
* 마법 숫자가 상수의 용도와 맞는지 살펴보고, 그렇다면 마법 숫자를 상수로 교체한다.
* 컴파일한다.
* 모든 마법 숫자를 상수로 고쳤으면 테스트를 실시한다. 이때 모든 기능이 수정 전과 동일하게 작동해야 한다.
  * 좋은 테스트 방법은 상수를 쉽게 수정할 수 있는지 살펴보는 것이다. 몇몇 예상 결과를 변경해도 새 값과 일치해야 한다. 항상 수정할 수 있는 건 아니지만, 작동할 경우엔 괜찮은 편법이다.
<hr/>
 
 ### 필드 캡슐화
 *public 필드가 있을 땐 그 필드를 private로 만들고 필드용 읽기 메서드와 쓰기 메서드를 작성한다.*
 ```
 public String _name
 ```
 ```
 private String _name;
 public String getName() {return _name;}
 public void setName(String arg) {_name = arg;}
 ```
 ##### 동기
 객체지향의 주요 원칙 중 하나는 캡슐화다. 캡슐화를 '데이터 은닉'이라고 부르기도 한다. 그래서 데이터는 절대로 public 타입으로 선언하면 안 된다. 데이터를 public 타입으로 만들면 데이터가 있는 객체가 모르는 사이에 다른 객체가 데이터 값을 읽고 변경할 수 있다. 이로 인해 데이터가 기능과 분리된다. 
 
 이것이 좋지 않은 이유는 프로그램의 모듈성을 저하하기 때문이다. 데이터와 데이터를 사용하는 기능이 한 곳에 모여 있으면 수정한 코드가 프로그램 여기저기에 흩어져 있지 않고 한 곳에 있어서 코드를 수정하기 쉽다.
 
 필드 캡슐화 과정의 첫 단계는 데이터는 은닉하고 읽기/쓰기 메서드를 추가하는 것이다. 읽기 메서드와 쓰기 메서드만 있는 클래스는 객체의 장점을 전혀 활용하지 않아서 개체라는 이름조차 아까운 멍청한 클래스다. 필드 캡슐화를 적용한 후엔 새 메서드를 사용하는 메서드를 찾아 그 메서드를 묶어서 간단한 메서드 이동을 적용해 새 객체로 옮겨도 괜찮을지 확인한다.
 ##### 방법
 * 캡슐화할 필드를 읽고 쓰기 위한 읽기 메서드와 쓰기 메서드를 작성한다.
 * 클래스 외부에서 그 필드를 참조하는 모든 부분을 찾는다. 찾아낸 참조 부분이 값을 읽는 코드라면 그 참조 부분을 읽기 메서드 호출로 수정하고, 값을 변경하는 코드라면 쓰기 메서드 호출로 수정한다.
  * 만약 그 필드가 객체이고 필드 참조 부분이 해당 객체에서 변경 메서드를 호출한다면 그건 값을 읽는 코드다. 대입문이 사용된 부분만 쓰기 메서드 호출로 수정한다.
* 하니씩 수정할 때마다 컴파일과 테스트를 실시한다.
* 필드를 참조하는 부분을 전부 수정했으면 그 필드의 선언 타입을 private로 수정한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 컬렉션 캡슐화
*메서드가 컬렉션을 반환할 땐 그 메서드가 읽기전용 뷰를 반환하게 수정하고 추가 메서드와 삭제 메서드를 작성한다.*
##### 동기
클래스에 여러 인스턴스로 구성된 컬렉션이 들어 있는 경우를 흔히 볼 수 있다. 그 컬렉션은 배열, 리스트, 세트, 벡터 중 하나일 수 있다. 이럴 땐 십중팔구 컬렉션을 읽고 쓸 수 있는 평범한 읽기 메서드와 쓰기 메서드가 있기 마련이다.

그러나 컬렉션은 다른 종류의 데이터와는 약간 다른 읽기/쓰기 방식을 사용해야 한다. 읽기 메서드는 컬렉션 객체 자체를 반환해서는 안 된다. 왜냐하면 컬렉션 참조 부분이 컬렉션의 내용을 조작해도 그 컬렉션이 든 클래스는 무슨 일이 일어나는지 모르기 때문이다. 이로 인해 컬렉션 참조 코드에게 그 객체의 데이터 구조가 지나치게 노출된다. 값이 여러 개인 속성을 읽는 읽기 메서드는 컬렉션 조작이 불가능한 형식을 반환하고 불필요하게 자세한 컬렉션 구조 정보는 감춰야 한다.

그리고 컬렉션 쓰기 메서드는 절대 있으면 안 되므로, 원소를 추가하는 메서드와 삭제하는 메서드를 대신 사용해야 한다. 이렇게 하면 컬렉션이 든 객체가 컬렉션의 원소 추가와 삭제를 통제할 수 있다. 

이런 규칙대로 설계를 고치면, 컬렉션은 적절히 캡슐화되어 컬렉션이 든 클래스의 컬렉션 참조부분에 대한 종속성이 줄어든다.
##### 방법
* 컬렉션 원소를 추가하는 add 메서드와 삭제하는 remove 메서드를 추가한다.
* 필드를 빈 컬렉션으로 초기화한다.
* 컴파일한다.
* 쓰기 메서드 호출 부분을 찾아서 add 메서드와 remove 메서드 호출로 바꾸든지, 그 위치에 직접 컬렉션에 원소를 추가하고 삭제하는 코드를 작성한다.
  * 쓰기 메서드가 사용되는 경우는 두 가지다. 첫째는 컬렉션이 비어 있을 때고, 둘째는 비어 있지 않은 컬렉션을 교체할 때다.
  * 메서드명 변경을 실시해서 쓰기 메서드의 이름을 변경해야 할 수도 있다.
* set이라는 이름을 initialize나 replace로 수정한다.
* 컴파일과 테스트를 실시한다.
* 읽기 메서드를 호출하여 컬렉션을 변경하는 부분을 전부 찾아서, add 메서드 호출과 remove 메서드 호출로 바꾼다. 하나씩 수정할 때마다 컴파일과 테스트를 실시한다.
* 컬렉션을 변경하고자 읽기 메서드를 호출하는 부분을 전부 추가/삭제 메서드 호출로 고쳤으면, 컬렉션의 읽기 전용 뷰를 반환하게 읽기 메서드를 수정한다.
  * 자바 2에선 컬렉션의 읽기 전용 뷰가 적절한 수정불가 컬렉션 뷰다.
  * 자바 1.1에선 컬렉션 사본을 반환해야 한다.
* 컴파일과 테스트를 실시한다.
* 읽기 메서드 호출 부분을 찾고 컬렉션이 든 객체로 옮겨야 할 코드를 찾아서 메서드 추출과 메서드 이동을 실시해서 컬렉션이 든 객체로 옮긴다.
<hr/>

### 레코드를 데이터 클래스로 전환
*전통적인 프로그래밍 환경에서 레코드 구조를 이용한 인터페이스를 제공해야 할 땐 레코드 구조를 저장할 덤 데이터 객체를 작성한다.*
##### 동기
프로그래밍 환경에서 레코드 구조는 흔히 사용된다. 객체지향 프로그램에 레코드 구조를 사용하는 이유는 다양한다. 구버전 프로그램을 복사할 수도 있고, 구조화된 레코드를 기존의 프로그래밍 API나 데이터베이스 레코드와 소통하게 할 수도 있다. 이럴 경우, 이러한 외부 요소를 처리할 인터페이스 역할을 하는 클래스를 작성하는 것이 좋다. 클래스를 외부 레코드처럼 만드는 것은 간단한다. 다른 필드와 메서드는 나중에 클래스로 옮기면 된다. 비교적 불명확하지만 더 그럴싸한 예는 각 인덱스에 들어 있는 원소에 특수한 의미가 있는 배열이다. 이 경우에는 배열을 객체로 전환을 실시한다.
##### 방법
* 레코드를 표현할 클래스를 작성한다.
* 이 클래스에 각 데이터 항목에 대한 읽기 메서드와 쓰기 메서드를 작성하고 private 필드를 선언한다.
<hr/>

### 분류 부호를 클래스로 전환
*기능에 영향을 미치는 숫자형 분류 부호가 든 클래스가 있을 땐 이 숫자를 새 클래스로 바꾼다.*
##### 동기
숫자형 분류 부호, 즉 열거 타입은 C 언어를 기반으로 하는 각종 언어에 공통적으로 존재한다. 분류 부호 이름을 상징적인 것으로 정하면 코드가 상당히 이해하기 쉬워진다. 문제는 상징적 이름은 단지 별명에 불과하다는 점이다. 컴파일러는 어차피 내부의 숫자를 읽는다. 컴파일러는 분류 부호의 종류를 상징적 이름이 아닌 숫자를 보고 판단한다. 분휴 부호를 인자로 받는 모든 메서드는 숫자만을 인자로 받으며, 상징적 이름을 전달할 방법은 없다. 그래서 코드를 이해하기 힘들어질 수 있고 버그가 생길 수도 있다.

숫자형 분류 부호를 클래스로 빼내면 컴파일러는 그 클래스 안에서 종류 판단을 수행할 수 있다. 그 클래스 안에 팩토리 메서드를 작성하면 유효한 인스턴스만 생성되는지와 그런 인스턴스가 적절한 객체로 전달되는지를 정적으로 검사할 수 있다.

하지만 무작정 분류 부호를 클래스로 전환기법을 실시할 것이 아니라, 그 전에 분류 부호를 다른 것으로 전환하는 방안도 고려해야 한다. 분류 부호를 클래스로 만드는 건 분류 부호가 순수한 데이터일 때만 실시해야 한다. 다시 말해, 분류 부호가 switch 문 안에 사용되어 다른 기능을 수행하거나 메서드를 호출할 땐 클래스로 전환하면 안 된다. 자바의 switch 문에는 임의로 클래스를 사용할 수 없으며 오직 정수 타입만 사용 가능하므로 클래스로의 전환은 실패를 맞게 된다. 더 중요한 건, 모든 switch 문은 조건문을 재정의로 전환기법을 적용해 전부 없애야 한다는 사실이다. 조건문을 재정의로 전환기법을 실시하려면 우선 분휴 부호를 하위 클래스로 전환이나 분휴 부호를 상태/전략 패턴으로 전환기법을 적용해서 분류 부호부터 처리해야 한다.

혹여 분류 부호가 값에 따라 다른 기능을 호출하지 않더라도 분류 부호 클래스로 만들면 더 좋은 기능이 있을 수도 있으므로, 메서드 이동기법을 한두 차례 실시할 것을 고려해야 한다.
##### 방법
* 분류 부호의 종류를 판단할 새 클래스를 작성한다.
  * 그 클래스 안에 분류 부호와 대응하는 code 필드를 선언하고 그 값을 읽을 읽기 메서드를 작성한다. 그 클래스에서 생성이 허용되는 인스턴스를 저장할 static 변수와, 원래의 클래스에 따라 다른 인자를 받아서 적절한 인스턴스를 반환하는 static 메서드를 저장할 static 변수도 선언해야 한다.
* 새 클래스를 사용하게 원본 클래스의 내용을 수정한다.
  * 기존 코드를 사용하는 인터페이스는 그대로 놔두되, static 필드는 새 클래스를 통해 코드를 생성하게 수정한다. 다른 코드를 사용하는 메서드도 새 클래스에서 부호 숫자를 읽게 수정한다.
* 컴파일과 테스트를 실시한다.
  * 이제 새 클래스는 코드를 런타임에 검사할 수 있다.
* 원본 클래스 코드를 사용하는 원본 클래스 안의 각 메서드마다, 그에 대응하는 새 클래스를 사용하는 새 메서드를 작성한다.
  * 코드를 인자로 받는 메서드는 새 클래스의 인스턴스를 인자로 받는 새 메서드로 바꿔야 한다. 코드를 반환하는 메서드는 새 클래스 인스턴스를 반환하는 새 메서드로 바꿔야 한다. 기존 코드를 사용하는 프로그램을 더욱 이해하기 쉽게 만들려면 새 읽기/쓰기 메서드를 작성하기 전에 기존의 읽기/쓰기 메서드에 메서드명 변경을 적용해야 한다.
* 원본 클래스 호출 부분을 한 번에 하나씩 새 인터페이스 호출로 수정한다.
* 전부 수정했으면 컴파일과 테스트를 실시한다.
  * 컴파일과 테스트 결과가 일관되게 나오기까지 여러 메서드를 수정해야 할 가능성도 있다.
* 기존 코드를 사용하는 기존 인터페이스를 삭제하고, 기존 코드의 static 변수 선언도 삭제한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 분류 부호를 하위클래스로 전환
*클래스 기능에 영향을 주는 변경불가 분류 부호가 있을 땐 분류 부호를 하위클래스로 만든다.*
##### 동기
클래스 기능에 영향을 주지 않는 분류 부호가 있을 땐 분류 부호를 클래스로 전환기법을 실시하면 된다. 그러나 분류 부호가 클래스 기능에 영향을 준다면 재정의를 통해 조금씩 다른 기능을 처리하는 것이 최선이다.

분류 부호가 클래스 기능에 영향을 미치는 현상은 case 문 같은 조건문이 있을 때 주로 나타난다. 그런 조건문은 switch 문 아니면 if-then-else 문이다. 이런 조건문은 조건문을 재정의로 전환을 실시해서 재정의로 바꿔야 한다. 이 기법이 효과를 보려면 분류부호를 다형화된 기능이 든 상속 구조로 고쳐야 한다. 이런 상속 구조는 하나의 클래스와 각 분류 부호에 대한 하위클래스로 구성된다. 

이런 상속 구조를 만드는 제일 간단한 방법이 바로 분류 부호를 하위클래스로 전환을 실시하는 것이다. 분류 부호가 든 클래스 코드를 이용해 각 분류 부호별 하위클래스를 작성한다. 단, 이 기법을 적용할 수 없는 몇가지 경우가 있다.
* 분류 부호의 값이 객체 생성 후 변할 때
* 다른 이유로 분류 부호를 이미 하위클래스로 만들었을 때
* 분류 부호를 상태/전략 패턴으로 전환을 실시해야 할 때

분류 부호를 하위클래스로 전환기법은 주로 조건문을 재정의로 전환을 가능하게 하는 사전 작업으로 시행할 때가 많다. 분류 부호를 하위클래스로 전환기법은 조건문이 있으면 실시한다. 조건문이 없다면 분류 부호를 클래스로 전환기법을 적용하는 게 위험성도 낮고 더 적절하다.

특정 분류 부호의 객체에만 관련된 기능이 있을 때도 분류 부호를 하위클래스로 전환기법을 적용해야 한다. 이 기법을 적용하고 나면 메서드 하향과 필드 하향기법을 적용해서 그런 기능이 특정 경우에만 관련되어 있음을 분명히 나타낼 수 있다.

분류 부호를 하위클래스로 전환 기법의 장점은 클래스 사용 부분에 있던 다형적인 기능 관련 데이터가 클래스 자체로 이동한다는 데 있다. 변형된 새 기능을 추가할 땐 하위클래스만 하나 추가하면 되기 때문이다. 다형성, 즉 재정의를 이용하지 않는다면 조건문을 전부 찾아서 일일이 수정해야 한다. 이 리팩토링 기법의 가치는 다형적인 기능이 수시로 변할 때 특히 빛난다.
##### 방법
* 분류 부호를 자체 캡슐화한다.
  * 분류 부호가 생성자 메서드로 전달될 땐 생성자 메서드를 팩토리 메서드로 바꿔야 한다.
* 각 분류 부호 값마다 그에 해당하는 하위클래스를 작성한다. 그 하위클래스 안에 관련 값을 반환하는 분류 부호 읽기 메서드를 재정의한다.
  * 반환 값은 return 1 같이 return 문으로 하드코딩된다. 복잡해 보여도 모든 case 문을 수정할 때까진 임시방편으로 취하는 불가피한 조치다.
* 각 분류 부호 값을 하위클래스로 만들 때마다 컴파일과 테스트를 실시한다.
* 상위클래스의 분류 부호 필드를 삭제한다. 분류 부호 읽기 메서드와 쓰기 메서드를 abstract 타입으로 선언한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 분류 부호를 상태/전략 패턴으로 전환
*분류 부호가 클래스의 기능에 영향을 주지만 하위클래스로 전환할 수 없을 땐 그 분류 부호를 상태 객체로 만든다.*
##### 동기
이 기법은 분류 부호를 하위클래스로 전환과 비슷하지만, 분류 부호가 객체 수명주기 동안 변할 때나 다른 이유로 하위클래스로 만들 수 없을 때 사용한다. 이 기법은 상태 패턴이나 전략 패턴 중 하나를 사용한다.

상태 패턴과 전략 패턴은 서로 비슷하므로 사용하는 리팩토링 기법도 같다. 특정 상황에 더 잘 맞는 패턴을 선택한다. 조건문을 재정의로 전환으로 하나의 알고리즘을 단순화해야 할 때는 전략이 더 적절하며, 상태별 데이터를 이동하고 객체를 변화하는 상태로 생각할 때는 상태 패턴이 더 적절하다.
##### 방법
* 분류 부호를 자체 캡슐화한다.
* 분류 부호의 목적을 나타내는 이름으로 새 클래스를 작성한다. 이것이 상태 객체다.
* 그 상태 객체에 각 분류 부호에 해당하는 하위클래스를 추가한다.
  * 하위클래스 추가는 한 번에 하나씩보단 한꺼번에 추가하는 것이 간편한다.
* 상태 객체 안에 분류 코드를 반환하는 abstract 메서드 호출을 작성한다. 올바른 분류 부호를 반환하는 상태 객체 하위클래스 각각에 대한 재정의 메서드 호출을 작성한다.
* 컴파일한다.
* 원본 클래스 안에 새 상태 객체를 나타내는 필드를 선언한다.
* 원본 클래스에 있는 분류 부호 판단 코드를 상태 객체에 위임하게 수정한다.
* 원본 클래스의 분류 부호 쓰기 메서드를 적절한 상태 객체 하위클래스의 인스턴스를 할당하게 수정한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 하위클래스를 필드로 전환
*여러 하위클래스가 상수 데이터를 반환하는 메서드만 다를 땐 각 하위클래스의 메서드를 상위클래스 필드로 전환하고 하위클래스는 전부 삭제한다.*
##### 동기
기능을 추가하거나 기능을 조금씩 달리할 하위클래스를 작성한다. 다형적인 기능의 한 형태는 상수 메서드다. 상수 메서드는 하드코딩된 값을 반환하는 메서드다. 상수 메서드는 읽기 메서드에 각기 다른 값을 반환하는 하위클래스에 넣으면 유용하다. 상위클래스 안에 읽기 메서드를 정의하고 그 읽기 메서드를 하위 클래스에서 다양한 값으로 구현한다.

상수 메서드가 유용하긴 해도, 하위클래스를 상수 메서드로만 구성한다고 해서 그만큼 효용성이 커지는 것은 아니다. 상위클래스 안에 필드를 넣고 그런 하위클래스는 완전히 삭제하면 된다. 그렇게 하면 하위클래스의 불필요한 복잡함도 사라진다.
##### 방법
* 하위클래스에 생성자를 팩토리 메서드로 전환을 적용한다.
* 하위클래스 참조 부분을 전부 상위클래스 참조로 수정한다.
* 상위클래스에 각 상수 메서드에 대한 final 타입의 필드를 선언한다.
* protected 타입의 상위클래스 생성자를 선언해서 필드를 초기화한다.
* 하위클래스 생성자를 추가하거나 수정해서 새 상위클래스 생성자를 호출한다.
* 컴파일과 테스트를 실시한다.
* 상위클래스 안에 필드를 반환하는 각 상수 메서드를 구현하고 하위클래스의 메서드는 삭제한다.
* 하나씩 삭제할 때마다 컴파일과 테스트를 실시한다.
* 하위클래스 메서드를 전부 삭제했으면 메서드 내용 직접 삽입기법을 실시해서 생성자 메서드 내용을 상위클래스의 팩토리 메서드에 직접 넣는다.
* 컴파일과 테스트를 실시한다.
* 하위클래스를 삭제한다.
* 컴파일과 테스트를 실시한다.
* 생성자 메서드 내용을 다시 팩토리 메서드에 직접 넣고, 작업이 완료되면 각 하위클래스를 삭제한다.
