# 조각 맞추기
### 리팩토링 학습
* 습관적으로 목표를 정한다
  * 자신이 담당하는 코드의 어느 부분에선가 구린내가 풍기면, 그 구린내를 없애겠다는 결의를 다진 후 그 목표를 향해 나아간다. 
* 확인이 없으면 중단한다
  * 목표를 향해 전진할 때, 현재 실시하는 작업이 프로그램의 목적을 보전하리란 사실을 자신이나 남에게 확실히 입증할 수 없는 순간이 닥칠 수도 있다. 이때는 중단해야 한다. 중단한 시점에 코드가 이미 개선됐다면 그 결과물을 출시하고, 나아진 게 없다면 수정한 코드를 쓰레기통에 던져 넣는다.
* 되돌아간다
  * 리팩토링 원리는 배우긴 어렵고 잠시나마 방향을 잘못 들긴 쉽다. 
* 작업은 둘이서 한다
  * 어떤 종류의 개발이든 짝을 이뤄 작업하면 많은 장점이 있다. 리팩토링은 조심스럽게 체계적으로 작업해야 한다. 이때 파트너가 있으면 계속 단계적으로 작업하라고 조언도 하고 반대로 그 파트너가 잘못하는 부분도 지적해줄 수 있다. 파트너는 자신이 못보는 부분을 봐주고 모르는 것을 알려준다. 또한, 파트너가 있으면 포기하고 싶을 때 다정하게 격려해준다. 

> * 지금 코드가 미치도록 지저분하더라도 그 문제점을 조금씩 바로잡아 나가는 연습을 해야 한다.
> * 한 부분에 새 기능을 추가하려면 몇 분 정도를 할애해서 코드 정리부터 한다.
> * 몇 가지 테스트를 추가해야 확신을 갖고 정리할 수 있다면 테스트를 추가한다.

리팩토링을 먼저 하는 것은 새 코드를 추가하는 것보단 덜 위험하다. 코드에 손대면 그 코드의 원리가 떠오르게 된다. 그래서 작업 속도는 더 빨라지고, 다음에 다시 볼 땐 코드가 지금보다 깔끔해 보일 거란 확신이 들어 기분이 좋을 것이다.

리팩토링할 땐 코드가 리팩토링하기 전의 기능을 그대로 유지하는 것이 목표다. 기능이 늘거나 줄면 안 된다. 일단은 추가하거나 수정할 테스트 케이스, 관련 없는 리팩토링 기법, 작성할 문서, 그려야 할 도표 같이 나중에 수정할 사항을 목록으로 작성해 둔다. 이렇게 하면 생각을 잊어버릴 일도 없고, 그런 생각들 때문에 현재의 작업을 망치는 일도 없다.
<hr/>

### 주요 지침과 정의
* 프로그램에 기능을 추가해야 하는데 코드 구조가 조잡해서 그 기능을 추가하기 힘들다면, 우선 리팩토링을 실시해서 기능을 추가하기 쉽게 만든 후 그 기능을 추가한다.
* 리팩토링하기 전에 반드시 신뢰도 높은 테스트 스위트가 준비됐는지 확인한다. 이 테스트들은 반드시 자체검사가 되게 작성한다.
* 리팩토링은 프로그램을 조금씩 단계적으로 수정하므로 실수해도 버그를 찾기가 쉽다.
* 컴퓨터가 인식 가능한 코드는 바보라도 작성할 수 있지만, 인간이 이해할 수 있는 코드는 실력 있는 프로그래머만 작성할 수 있다.
* 리팩토링(명사): 겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업
* 리팩토링(동사): 리팩토링 기법을 연달아 적용해서 겉으로 드러나는 기능은 그대로 둔 채 소프트웨어 구조를 변경한다.
* 같은 작업을 3번째 반복하게 됐을 때 리팩토링을 실시한다.
* 인터페이스를 함부로 배포타입으로 만들지 않는다. 팀원 간의 트러블이 생기지 않는 융통성 있는 리팩토링을 위해 코드 소유권 정책을 수정한다.
* 주석을 넣어야겠다는 생각이 들 땐 먼저 코드를 리팩토링해서 주석을 없앨 수 있게 만들어본다.
* 모든 테스트를 완전히 자동화하고 결과를 자체적으로 검사하게 한다.
* 테스트 스위트는 버그를 찾는 시간을 획기적으로 줄여주는 강력한 버그 감지 도구다.
* 테스트를 자주 실행한다. 적어도 하루에 한 번은 테스트를 실시하고, 컴파일할 때마다 테스트를 국소화한다.
* 버그 리포트를 받으면 우선 그 버그를 한눈에 볼 수 있게 출력하는 단위테스트부터 작성한다.
* 완벽한 테스트를 작성하려다 아예 테스트를 포기하느니, 차라리 불완전한 테스트를 작성해 실행하는 편이 낫다.
* 잘못될 수 있는 경계 조건을 생각한 후, 그 상황에서의 테스트에 집중한다.
* 뭔가 에러가 있으리라 예상될 땐 그 예외가 정말로 발생하는지 꼭 테스트한다.
* 테스트가 모두는 아니더라도 대부분의 버그는 잡아내므로 테스트 작성을 중단해선 안 된다.
<hr/>

### 리팩토링 기법
* Null 검사를 널 객체에 위임
* 값을 참조로 전환
* 객체를 통째로 전달
* 계층 병합
* 계층구조 추출
* 과잉 중개 메서드 제거
* 관측 데이터 복제
* 국소적 상속확장 클래스 사용
* 대리 객체 은폐
* 데이터 값을 객체로 전환
* 도메인 로직을 표현과 분리
* 레코드를 데이터 클래스로 전환
* 마법 숫자를 기호 상수로 전환
* 매개변수 세트를 객체로 전환
* 매개변수 세트를 메서드로 전환
* 매개변수 제거
* 매개변수 추가
* 매개변수로의 값 대입 제거
* 매개변수를 메서드로 전환
* 메서드 내용 직접 삽입
* 메서드 상향
* 메서드 은폐
* 메서드 이동
* 메서드 추출
* 메서드 하향
* 메서드를 매개변수로 전환
* 메서드를 메서드 객체로 전환
* 메서드명 변경
* 배열을 객체로 전환
* 분류 부호를 상태/전략 패턴으로 전환
* 분류 부호를 클래스로 전환
* 분류 부호를 하위클래스로 전환
* 상속 구조 정리
* 상속을 위임으로 전환
* 상위클래스 추출
* 상태 변경 메서드와 값 반환 메서드를 분리
* 생성자 내용 상향
* 생성자를 팩토리 메서드로 전환
* 쓰기 메서드 제거
* 알고리즘 전환
* 어설션 넣기
* 에러 부호를 예외 통지로 교체
* 여러 겹의 조건문을 감시 절로 전환
* 예외 처리를 테스트로 교체
* 외래 클래스에 메서드 추가
* 위임을 상속으로 전환
* 인터페이스 추출
* 임시변수 내용 직접 삽입
* 임시변수 분리
* 임시변수를 메서드 호출로 전환
* 절차 코드를 객체로 전환
* 제어 플래그 제거
* 조건문 쪼개기
* 조건문을 재정의로 전환
* 조건문의 공통 실행 코드 빼내기
* 중복 조건식 통합
* 직관적 임시변수 사용
* 참조를 값으로 전환
* 컬렉션 캡슐화
* 클래스 내용 직접 삽입
* 클래스 추출
* 클래스의 단방향 연결을 양방향으로 전환
* 클래스의 양방향 연결을 단방향으로 전환
* 템플릿 메서드 형성
* 필드 상향
* 필드 이동
* 필드 자체 캡슐화
* 필드 캡슐화
* 필드 하향
* 하위클래스 추출
* 하위클래스를 필드로 전환
* 하향 타입 변환을 캡슐화
<hr/>

### 구린내와 탈취 기법
구린내 | 탈취를 위한 리팩토링 기법
:-------:|:---------:
switch 문 | 조건문을 재정의로 전환, 분류 부호를 하위클래스로 전환, 분류 부호를 상태/전략 패턴으로 전환, 매개변수를 메서드로 전환, Null 검사를 널 객체에 위임
강박적 기본 타입 사용 | 데이터 값을 객체로 전환, 클래스 추출, 매개변수 세트를 객체로 전환, 배열을 객체로 전환, 분류 부호를 클래스로 전환, 분류 부호를 하위클래스로 전환, 분류 부호를 상태/전략 패턴으로 전환
과다한 매개변수 | 매개변수 세트를 메서드로 전환, 매개변수 세트를 객체로 전환, 객체를 통째로 전달
과잉 중개 메서드 | 과잉 중개 메서드 제거, 메서드 내용 직접 삽입, 위임을 상속으로 전환
기능의 산재 | 메서드 이동, 필드 이동, 클래스 내용 직접 삽입
데이터 뭉치 | 클래스 추출, 매개변수 세트를 객체로 전환, 객체를 통째로 전달
데이터 클래스 | 메서드 이동, 필드 캡슐화, 컬렉션 캡슐화
막연한 범용 코드 | 계층 병합, 클래스 내용 직접 삽입, 매개변수 제거, 메서드명 변경
메시지 체인 | 대리 객체 은폐
미흡한 라이브러리 클래스 | 외래 클래스에 메서드 추가, 국소적 상속확장 클래스 사용
방대한 클래스 | 클래스 추출, 하위클래스 추출, 인터페이스 추출, 데이터 값을 객체로 전환
방치된 상속물 | 상속을 위임으로 전환
불필요한 주석 | 메서드 추출, 어설션 넣기
수정의 산발 | 클래스 추출
인터페이스가 다른 대용 클래스 | 메서드명 변경, 메서드 이동
임시 필드 | 클래스 추출, Null 검사를 널 객체에 위임
잘못된 소속 | 메서드 이동, 필드 이동, 메서드 추출
장황한 메서드 | 메서드 추출, 임시변수를 메서드 호출로 전환, 메서드를 메서드 객체로 전환, 조건문 쪼개기
중복 코드 | 메서드 추출, 클래스 추출, 메서드 상향, 템플릿 메서드 형성
지나친 관여 | 메서드 이동, 필드 이동, 클래스의 양방향 연결을 단방향으로 전환, 상속을 위임으로 전환, 대리 객체 은폐
직무유기 클래스 | 클래스 내용 직접 삽입, 계층 병합
평행 상속 계층 | 메서드 이동, 필드 이동

