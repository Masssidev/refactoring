# 복합 리팩토링
* 리팩토링은 개발 작업을 지연시키려고 하는 게 아니라 어떤 목적이 있어서 하는 것이다. 
* 리팩토링은 주변 정리부터 매일 조금씩 해나가야 한다.
* 리팩토링은 기능을 추가할 때나 버그를 수정할 때 실시한다.
* 실제 작업을 수행하는 데 필요한 만큼 한다.
* 필요하다면 나중에 언제든지 되돌릴 수 있다.
* 복합 리팩토링은 단순 리팩토링 기법과 달리 개발 팀 전원의 합의 하에 실시해야 한다.
* 복합 리팩토링을 하다 보면 수정 방향이 꽤 많이 바뀐다.
* 팀 전원은 복합 리팩토링 중 하나가 현재 진행 중임을 알고 그에 따라 움직여야 한다.
* 충분히 이해하지 못한 상태에서 설계를 결정하는 일이 누적되면 막 자란 물풀로 막힌 운하처럼 프로그램이 막혀버린다.
* 리팩토링하면 개발자는 설계할 프로그램을 완전히 이해하고 그 내용을 항상 프로그램에 반영할 수 있다.
<hr/>

### 상속 구조 정리
*하나의 상속 계층이 두 작업을 동시에 수행할 땐 상속 계층을 하나 더 만들어서 위임을 통해 다른 계층을 호출한다.*
##### 동기
상속 구조로 만들면 하위클래스 안에 작성할 코드가 상당히 줄어든다. 메서드 하나는 비록 크기는 작지만 상속 계층에 들어 있다는 것만으로 상당히 중요하다.

이런 강력한 메커니즘으로 인해 상속을 오용하기 쉽다. 그리고 이런 오용은 모르는 사이 쌓여간다. 나중에는 상속 구조를 풀기 힘들 정도로 복잡하게 얽힌다.

상속 계층이 엉키면 코드 중복이 생겨서 문제다. 특정 문제를 해결하는 데 필요한 기법들이 여기저기 퍼져 있어서 코드를 수정하기도 더 어려워진다. 결국 코드를 알아보기도 힘들어진다.

두 기능을 수행하는 하나의 상속 계층은 쉽게 찾을 수 있다. 계층구조의 특정 계층에 있는 모든 클래스의 하위클래스들이 이름 앞에 같은 형용사가 붙어 있다면 한 계층으로 두 기능을 수행하는 것이다.
##### 방법
* 계층구조에 의해 수행되는 각종 기능들을 확인한다. 2차원 테이블을 그리고 가로 축과 세로 축에 기능을 나타내는 라벨을 붙인다(아주 좋은 그래프 용지가 있다면 3차원이나 4차원 테이블을 그린다). 테이블이 2차원 이상이라면 이 리팩토링을 한 번에 하나씩 반복 적용해야 한다.
* 기능의 우선순위를 정하고, 어떤 기능을 현재 계층에 남겨두고 어떤 기능을 다른 계층으로 옮길지 정한다.
* 공통 상위클래스에 6장의 클래스 추출을 적용해서 원본 계층에 있는 각 하위클래스별 객체를 작성하고 이 객체를 저장할 인스턴스 변수를 선언한다.
* 공통된 상위클래스에 6장의 클래스 추출을 적용해서 원본 클래스 안 각 하위클래스를 추출한 객체의 하위클래스로 만든다. 앞 단계에서 선언한 인스턴스 변수를 이 하위클래스의 인스턴스로 초기화한다.
* 하위클래스마다 7장의 메서드 이동을 실시해서 하위클래스의 해당 기능을 관련된 추출 객체로 옮긴다.
* 하위클래스에 남아 있는 코드가 없으면 그 하위클래스를 삭제한다.
* 부수적인 하위클래스를 모두 삭제할 때까지 위 과정을 계속한다. 새 계층구조를 관찰하면서 11장의 메서드 상향이나 필드 상향 같은 리팩토링 기법을 실시할 여지가 있는지 살펴본다.
##### 예제
* 리팩토링을 한 번에 한 단계씩 거치는 것이 여러 단계를 한꺼번에 하는 것보다 더 안전하다.
<hr/>

### 절차 코드를 객체로 전환
*코드가 절차식으로 작성되어 있을 땐 데이터 레코드를 객체로 바꾸고, 기능을 쪼개서 각각의 객체로 옮긴다.*
##### 동기
객체를 잘 사용할 수 있게 되기까지는 시행착오와 학습 시간이 필요하다. 절차식 코드를 비교적 객체지향적으로 만들어야 할 때가 많다. 보통은 클래스에 몇 가지 데이터, 읽기/쓰기 메서드만으로 구성된 덤 데이터 객체, 절차식 메서드가 들어 있다. 완전한 절차식 프로그램을 변환할 때는 아예 이것조차 없을 수 있는데 차라리 그런 경우가 더 변환하기 쉽다.

그렇다고 해서 데이터가 거의 없거나 아예 없는 기능 위주의 객체를 작성해서는 안 된다는 이야기는 아니다. 기능을 변화시겨야 할 때는 작은 전략 객체를 사용할 때도 많다. 단, 그런 절차 객체는 보통 작으며 유연성을 위한 특수 용도로만 사용된다.
##### 방법
* 각 레코드 타입을 읽기/쓰기 메서드만 있는 덤 데이터 객체로 바꾼다.
  * 관계 데이터베이스를 사용한다면 각 테이블을 덤 데이터 객체로 바꾼다.
* 모든 절차 코드를 하나의 클래스에 넣는다.
  * 그 클래스를 싱글턴으로 만들든지, 메서드를 static 타입으로 만든다. 싱글턴으로 만드는 방법은 다시 초기화할 때 쉽다.
* 긴 프로시저를 대상으로 메서드 추출과 관련된 리팩토링 기법들을 실시해서 쪼갠다. 프로시저를 쪼개면서 메서드 이동을 적용해서 각각을 적절한 덤 데이터 클래스로 옮긴다.
* 원본 클래스에서 모든 기능을 삭제하게 될 때까지 계속한다. 원본 클래스가 순수한 절차 클래스였다면 그 클래스를 삭제할 때 속이 시원할 것이다.
<hr/>

### 도메인 로직을 표현과 분리
*도메인 로직이 들어 있는 GUI 클래스가 있을 땐 도메인 로직을 별도의 도메인 클래스로 떼어낸다.*
##### 동기
객체를 말할 때 모델-뷰-컨트롤러(MVC)는 빼놓을 수 없는 개념이다. 

MVC 패턴의 핵심은 사용자 인터페이스 코드(뷰, 표현)와 도메인 로직(모델)을 분리하는 것이다. 표현 클래스에는 사용자 인터페이스 처리에 필요한 로직만 들어간다. 도메인 객체에는 표현이나 시각적 코드는 전혀 들어가지 않고 비즈니스 로직만 들어간다. 이렇게 하면 프로그램의 복잡한 두 부분이 수정하기 쉬운 조각으로 분리되며, 하나의 비즈니스 로직에 여러 개의 표현을 구현할 수도 있다. 객체를 작업한 경력이 있는 개발자는 이러한 분리를 본능적으로 이용하며, 이런 분리 방식의 장점이 입증되었다.

그러나 클라이언트-서버 GUI를 사용하는 대부분의 프로그래밍 환경은 두 개의 논리 계층 설계(데이터는 데이터베이스에, 로직은 뷰에)를 이용한다. 이런 환경에서는 대체로 이런 방식의 설계 외에는 선택의 여지가 없어서 로직을 다른 곳에 넣기가 힘들어진다.

자바는 적절한 객체지향 언어라서, 비즈니스 로직이 든 표현 이외의 도메인 객체를 작성할 수 있다. 그러나 코드를 2계층 방식으로 작성해야 할 때가 많다.
##### 방법
* 각 Window 클래스가 사용할 도메인 클래스를 작성한다.
* 테이블이 있으면 그 테이블의 행을 나타내는 클래스를 작성한다. 도메인 클래스 안에 Window 클래스가 행 도메인 객체 저장에 사용할 컬렉션을 선언한다.
* Window 클래스의 데이터를 검사해서 그 데이터가 사용자 인터페이스에만 쓰이면 Window 클래스에 그대로 두고, 데이터가 창에 표시되진 않고 도메인 클래스 안에서만 사용되면 메서드 이동을 실시해서 그 데이터를 도메인 객체로 옮긴다. 사용자 인터페이스에도 사용되고 도메인 로직에도 사용되면 관측 데이터 복제를 실시해서 데이터를 두 클래스에 넣고 동기화를 유지한다.
* 표현 클래스에 로직이 있는지 검사해서, 있으면 메서드 추출을 실시해서 도메인 로직에서 표현 로직을 분리한다. 도메인 로직을 분리할 땐 메서드 이동을 실시해서 도메인 로직을 도메인 객체로 옮긴다.
* 앞 단계를 마치면 GUI를 처리하는 표현 클래스와 비즈니스 로직만 든 도메인 클래스가 생긴다. 도메인 클래스는 잘 수정되었을 수도 있지만, 그렇지 않다면 추가적인 리팩토링으로 그것을 처리하면 된다.
##### 예제
* 데이터베이스에서 처음에 도메인 모델을 이용하는 방식도 합리적이긴 하지만, 그럴 경우 표현과 도메인 로직이 섞일 수 있는 엄청난 위험이 따른다. 
* 모든 SQL 호출을 도메인 클래스로 옮기면 데이터베이스 로직과 도메인 데이터를 함께 도메인 클래스로 옮길 수 있다. 
* 이 리팩토링을 하면서 어디에 위험이 있는지 주의해야 한다. 표현과 도메인 로직의 혼합 위험성이 크다면 다른 작업은 제쳐두고 우선 그 둘을 완벽히 분리하는 것이 최우선이다. 
<hr/>

### 계층구조 추출
*한 클래스에 기능이 너무 많고 일부분에라도 조건문이 많을 땐 각 조건에 해당하는 하위클래스를 작성해서 계층구조를 만든다.*
##### 동기
단계적으로 보강해 나가는 방식으로 설계하다 보면, 처음엔 한 클래스에 하나의 기능만 구현하자고 생각하지만 나중엔 그 클래스 안에 심지어 기능을 10가지나 넣어버렸음을 깨달을 때가 많다. 개발자는 처음엔 클래스를 간단히 작성한다. 그러나 몇 주 정도 지났을 땐 플래그 하나와 몇 개의 테스트만 추가하면 새로운 상황에 그것을 응용할 수 있겠다는 생각이 든다. 한 달이 지나면 또 그와 비슷한 생각이 든다. 그런 식으로 1년이 지나면 플래그와 조건문이 여기저기 도배되어 그 클래스는 뒤죽박죽된다.

여러 기능이 있는 클래스가 있다면, 어떤 식으로든 그 기능들을 따로따로 분리해야 한다. 그렇게 하는 방법은 조건문이 객체의 수명 동안 지속될 때만 효력이 있다. 그렇기 않으면 아마 각 기능을 분리하기 전에 클래스 추출을 실시해야 할 수도 있다.

계층구조 추출은 짧은 시간에 마칠 수 없는 복합 리팩토링이지만 좌절할 것은 없다. 뒤죽박죽인 설계를 정리하려면 수주나 수개월이 걸릴 수도 있다. 쉽고 확인이 드는 단계부터 작업한 후 잠시 휴식을 취하면서 며칠간 성과가 보이는 다른 생산적인 일을 한다. 그러다 뭔가 느낌이 오면 다시 작업으로 돌아와서 더 쉽고 확신이 드는 단계를 실시한다.
##### 방법
###### 방법 1. 각 기능을 어디에 넣을지 모를 때 적용한다. 한 번에 한 단계씩 수행하는 것이 좋다.
* 각 기능을 확인하고 구분짓는다.
  * 객체가 존재할 동안 각 기능이 변할 수 있다면, 클래스 추출을 실시해서 각각의 클래스로 빼낸다.
* 해당 특수 상황별 하위클래스를 작성하고 원본 클래스에 생성자를 팩토리 메서드로 전환을 적용한다. 적절한 하위클래스의 인스턴스를 반환하게 팩토리 메서드를 수정한다.
* 조건문이 든 메서드를 한 번에 하나씩 하위클래스로 복사한 후 상위클래스와 하위클래스의 메서드의 기능을 알맞게 제한하여 단순화한다.
  * 필요하다면 상위클래스에 메서드 추출을 적용해서 메서드의 조건문을 나머지 코드와 분리한다.
* 상위클래스의 모든 메서드에 하위클래스 구현부가 들어갈 때까지 위의 단계를 각 기능별로 계속한다.
* 모든 하위클래스 안에 재정의한 메서드를 상위클래스에서 삭제하고 상위클래스를 abstract 타입으로 바꾼다.
###### 방법 2. 처음부터 각 기능이 확실히 구분될 때 사용한다.
* 각 기능별 하위클래스를 작성한다.
* 생성자를 팩토리 메서드로 전환을 적용해서 각 기능에 대응하는 하위클래스를 반환하게 한다.
  * 각 기능을 분류 부호로 구별했다면 분류 부호를 하위클래스로 전환을 실시한다. 단, 각 기능이 클래스가 존재하는 동안 변할 수 있다면 분류 부호를 상태/전략 패턴으로 전환을 실시한다.
* 조건문이 있는 메서드마다 조건문을 재정의로 전환을 적용한다. 각 메서드가 일부 코드만 다를 땐 다른 부분에만 메서드 추출을 적용해서 메서드로 빼낸다.
##### 예제
* 다른 기능 부분을 더 많이 메서드로 빼낼수록, 비슷한 메서드와 다른 메서드가 안정화되며 나중에 차이 나는 기능을 새로 넣기도 더 쉽다.

