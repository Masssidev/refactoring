# 조건문 간결화
조건문은 복잡해질 가능성이 높은 만큼, 복잡한 조건문을 간소화하는 리팩토링 기법도 다양하다.
<hr/>

### 조건문 쪼개기
*복잡한 조건문(if-then-else)이 있을 땐 if, then, else 부분을 각각 메서드로 빼낸다.*
```
if (date.before (SUMMER_START) || date.after(SUMMER_END))
  charge = quantity + _winterRate + _winterServiceCharge;
else charge = quantity * _summerRate;
```
```
if (notSummer(date))
  charge = winterCharge(quantity);
else charge = summerCharge(quantity);
```
##### 동기
프로그램에서 가장 복잡한 부분은 주로 복잡한 조건문이다. 조건을 검사하고 다양한 조건에 따라 다른 작업을 처리하는 코드를 작성하다 보면 금방 메서드가 길어진다. 메서드는 길어지기만 해도 알아보기 힘든데, 조건문까지 많으면 더 심각하다. 조건 검사 코드와 그에 따른 액션 코드를 보고 원리는 알 수 있지만, 왜 그렇게 되는지를 알기 힘들어서 주로 문제가 된다.

긴 코드가 다 그렇듯, 큰 덩어리의 코드를 잘게 쪼개고 각 코드 조각을 용도에 맞는 이름의 메서드 호출로 바꾸면 코드의 용도가 분명히 드러난다. 이 과정을 조건문의 if 절, then 절, else 절 각각에 대해 수행하면 더 큰 장점을 얻을 수 있다. 즉, 조건이 눈에 잘 들어오고 갈라지는 로직 흐름을 알아보기 쉽다. 게다가 로직을 왜 그렇게 갈라놨는지도 확실히 알 수 있다.
##### 방법
* if 절을 별도의 메서드로 빼낸다.
* then 절과 else 절을 각각의 메서드로 빼낸다.
조건문이 여러 겹일 땐 먼저 여러 겹의 조건문을 감시 절로 전환기법부터 실시한다. 그 결과가 만족스럽지 않으면 조건문을 쪼갠다.
<hr/>

### 중복 조건식 통합
*여러 조건 검사식의 결과가 같을 땐 하나의 조건문으로 합친 후 메서드로 빼낸다.*
```
double disabilityAmount() {
  if (_seniority <2) return 0;
  if (_monthsDisabled > 12) return 0;
  if (_isPartTime) return 0;
  // 장애인 공제액 산출
}
```
```
double disabilityAmount() {
  if (isNotEligableForDisability()) return 0;
  // 장애인 공제액 산출
}
```
##### 동기
서로 다른 여러 개의 조건 검사식이 있는데 조건에 따른 결과가 모두 같을 때가 간혹 있다. 이럴 때는 논리연산자 AND와 OR을 사용해서 여러 조건 검사를 하나로 합쳐야 한다.

###### 조건문 코드를 합쳐야 하는 이유
1. 조건식을 합치면 여러 검사를 OR 연산자로 연결해서 실제로 하나의 검사 수행을 표현해서 무엇을 검사하는지 더 확실히 이해할 수 있다.
2. 조건식 통합 리팩토링 기법을 실시하면 메서드 추출을 적용할 수 있는 기반이 마련된다. 조건식을 메서드로 추출하면 처리 중인 기능의 상태를 표현하던 코드가 기능 수행 목적을 표현하는 코드로 바뀐다.

조건 검사식이 독립적이고 하나의 검사로 인식되지 말아야 할 땐 이 리팩토링 기법을 실시하면 안 된다. 
##### 방법
* 모든 조건문에 부작용이 없는지 검사한다.
  * 하나라도 부작용이 있으면 이 리팩토링 기법을 실시할 수 없다.
* 여러 개의 조건문을 논리 연산자를 사용해 하나의 조건문으로 바꾼다.
* 컴파일과 테스트를 실시한다.
* 합친 조건문에 메서드 추출적용을 고려한다.
##### 예제
* AND, OR, NOT 연산자를 사용하면 여러 조건문을 하나의 조건식으로 연결할 수 있다. 단, 이렇게 하면 조건식이 복잡해질 수 있으니 합친 조건식에 메서드 추출을 적용해서 간단히 만드는 게 좋다.
* 조건식 안의 루틴이 단순히 조건을 검사해서 값을 반환할 땐 삼항연산자를 사용해서 그 루틴을 한 줄의 return 문으로 만든다.
<hr/>

### 조건문의 공통 실행 코드 빼내기
*조건문의 모든 절에 같은 실행 코드가 있을 땐 같은 부분을 조건문 밖으로 빼낸다.*
```
if(isSpecialDeal()) {
  total = price * 0.95;
  send();
}
else {
  total = price * 0.98;
  send();
}
```
```
if(isSpecialDeal())
  total = price * 0.95;
else
  total = price * 0.98;
send();
```
##### 동기
조건문의 절마다 같은 실행 코드가 들어 있을 때가 있다. 이럴 땐 그 부분을 조건문 밖으로 빼야 한다. 그래야 각 절이 공통적으로 실행할 기능과 서로 다르게 실행할 기능을 한눈에 알 수 있다.
##### 방법
* 조건에 상관없이 공통적으로 실행되는 코드를 찾는다.
* 공통 코드가 조건문의 앞 절에 있을 땐 조건문 앞으로 뺀다.
* 공통 코드가 조건문의 끝 절에 있을 땐 조건문 뒤로 뺀다.
* 공통 코드가 조건문의 중간 절에 있을 땐 앞뒤의 코드와 위치를 바꿔도 되는지 판단한다. 그래서 바꿔도 된다면 조건문의 앞이나 끝 절로 뺀 후 앞의 단계처럼 조건문 앞이나 뒤로 뺀다.
* 공통 코드 명령이 둘 이상일 땐 메서드로 만든다.
##### 예제
예외 처리에도 이 방식을 적용할 수 있다. 코드가 try 구간과 모든 catch 구간 안의 예외 발생 명령 뒤에 공통적으로 들어 있으면, 그 코드를 final 구간으로 옮기면 된다.
<hr/>

### 제어 플래그 제거
*논리 연산식의 제어 플래그 역할을 하는 변수가 있을 땐 그 변수를 break 문이나 return 문으로 바꾼다.*
##### 동기
여러 조건문이 사용된 코드에는 다음과 같이 조건문을 빠져나갈 시점을 결정하는 제어 플래그가 흔히 사용된다.
```
done 변수에 false 값 할당
while done이 false인 동안
  if (조건식)
    뭔가 기능을 수행
    done 변수에 true 값 할당
  루프의 다음 단계로 넘어감
```
제어 플래그는 유용함을 능가하는 단점이 있다. 진입점과 이탈점이 하나씩 있는 루틴을 호출하는 구조적 프로그래밍의 문법적 잔재다. 물론 진입점이 하나인 것엔 문제가 없지만 이탈점을 하나만 사용하면 코드 안의 각종 특이한 플래그로 인해 조건문이 복잡해진다. 그래서 프로그래밍 언어엔 복잡한 조건문을 방지하는 break 문과 continue 문이 있다. 제어 플래그를 없애면 의외로 많은 것을 할 수 있고 조건문의 진정한 의도를 쉽게 파악할 수 있다. 
##### 방법
* 자바에서는 다음과 같이 break 문이나 continue 문으로 제어 플래그를 확실히 없앨 수 있다.
  * 논리문을 빠져나오게 하는 제어 플래그 값을 찾는다.
  * 그 제어 플래그 값을 대입하는 코드를 break 문이나 continue 문으로 바꾼다.
  * 하나씩 바꿀 때마다 컴파일과 테스트를 실시한다.
* return 을 이용
  * 로직을 메서드로 빼낸다.
  * 논리문을 빠져나오게 하는 제어 플래그 값을 찾는다.
  * 빠져나오게 하는 값을 return 문으로 바꾼다.
  * 하나씩 바꿀 때마다 컴파일과 테스트를 실시한다.
  
메서드 추출 후 return 문으로 바꾸는 방법을 권장한다. return 문은 메서드 안에서 맨 끝에 있기 마련이므로, return 문을 넣으면 그 뒤에 더 이상 실행할 코드가 없음을 분명히 나타낼 수 있다. 대체로 return 문을 사용할 수 있는 코드가 있으면 무슨 수를 써서라도 그 부분을 메서드로 추출해야 한다.

제어 플래그가 결과 정보를 나타내는 역할도 하는지 살펴본다. 그럴 경우 break 문으로 수정했다면 제어 플래그는 여전히 필요하다. 그렇지 않고 메서드를 추출했다면 return 문으로 값을 반환하면 된다.
<hr/>

### 여러 겹의 조건문을 감시 절로 전환
*메서드에 조건문이 있어서 정상적인 실행 경로를 파악하기 힘들 땐 모든 특수한 경우에 감시 절을 사용한다.*
```
double getPayAmount() {
  double result;
  if (_isDead) result = deadAmount();
  else {
    if (_isSeparated) result = separatedAmount();
    else {
      if (_isRetired) result = retiredAmount();
      else result = normalPayAmount();
    };
  }
  return result;
};
```
```
double getPayAmount() {
  if (_isDead) return deadAmount();
  if (_isSeparated) return separatedAmount();
  if (_isRetired) return retiredAmount();
  return normalPayAmount();
};
```
### 동기
조건식은 주로 두 가지 형태를 띤다.
1. 어느 한 경로가 정상적인 동작의 일부인지 검사하는 형태
2. 조건식 판별의 한 결과만 정상적인 동작을 나타내고 나머지는 비정상적인 동작을 나타내는 형태

이런 조건문에는 다양한 의도가 있는데, 그 의도는 코드에 반영되어 드러나야 한다. 만약 둘다 정상 동작의 일부분이라면 if 절과 else 절로 구성된 조건문을 사용하고, 조건문이 특이한 조건이라면 그 조건을 검사해서 조건이 true일 경우 반환한다. 이런 식의 검사를 감시 절이라고 한다.

여러 겹의 조건문을 감시 절로 전환기법의 핵심은 강조 부분이다. if-then-else 문을 사용하면 if 절과 else 절의 비중이 동등하다. 따라서 코드를 보는 사람은 if 절과 else 절의 비중이 같다고 판단하게 된다. 그와 달리, 감시 절은 "이것은 드문 경우이니 이 경우가 발생하면 작업을 수행한 후 빠져나와라"하고 명령한다.

메서드에 진입점과 이탈점이 하나씩만 있다고 배운 프로그래머와 공동으로 작업할 때는 주로 여러 겹의 조건문을 감시 절로 전환기법을 사용한다. 유일한 진입점은 현대의 프로그래밍 언어에 표준처럼 굳어졌지만, 유일한 이탈점 규칙은 별로 바람직하지 않다. 코드의 명확성이 드러나는 것이 가장 중요하다. 메서드에 이탈점을 하나만 사용해서 더 명확해진다면 그렇게 해야겠지만, 그렇지 않을 때는 굳이 한 개의 이탈점을 고집할 필요가 없다.
##### 방법
* 조건 절마다 감시 절을 넣는다.
  * 그 감시 절은 값을 반환하거나 예외를 통지한다.
* 각 조건 절을 감시 절로 바꿀 때마다 컴파일과 테스트를 실시한다.
  * 모든 감시 절의 결과가 같다면 중복 조건식 통합기법을 실시한다.
##### 예제
여러 겹의 조건문 코드는 주로 메서드에 이탈점이 하나라고 배운 프로그래머들이 작성하는 경향이 있다. 메서드에 더 이상 중요한 작업이 남아 있지 않다면, 그 메서드를 빠져나오게 해서 관심이 없음을 나타내야 한다. 빈 else 문을 놔두면 코드를 보는 이에게 혼란을 줄 뿐이다.
<hr/>

### 조건문을 재정의로 전환

