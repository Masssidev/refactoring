# 메서드 호출 단순화
객체에서 가장 중요한 것은 인터페이스다. 이해와 사용이 쉬운 인터페이스를 작성하는 기술이야 말로 좋은 객체지향 소프트웨어 개발에 꼭 필요하다.
<hr/>

### 메서드명 변경
*메서드명을 봐도 기능을 알 수 없을 땐 메서드명을 직관적인 이름으로 바꾼다.*
##### 동기
메서드명만 봐도 그 메서드의 의도를 한눈에 알 수 있어야 한다. 메서드 기능을 설명하기 위해 넣는 주석을 떠올린 후 그 주석을 메서드명으로 바꾸면 이러한 메서드명을 쉽게 정할 수 있다.

메서드의 이름이 적절치 않다면 반드시 변경해야 한다. 코드는 컴퓨터보다 인간이 알아보기 쉽게 작성해야 한다. 인간이 알아보기 쉬우려면 코드에 사용된 모든 이름이 적절해야 한다. 
##### 방법
* 메서드 시그너처가 상위클래스나 하위클래스에 구현되어 있는지 검사한다. 만약 구현되어 있다면 각 구현부를 대상으로 다음 단계들을 실시한다.
* 새 이름으로 새 메서드를 선언한다. 코드의 원래 내용을 새 메서드로 복사하고 적절히 수정한다.
* 컴파일한다.
* 새 메서드를 호출하게 원본 메서드의 내용을 수정한다.
  * 참조하는 부분이 적다면 이 단계는 건너뛰어도 된다.
* 컴파일과 테스트를 실시한다.
* 원본 메서드 참조 부분을 전부 찾아서 새 메서드를 참조하게 수정한다. 수정할 때마다 테스트를 실시한다.
* 원본 메서드를 삭제한다.
  * 원본 메서드가 인터페이스에 들어 있어서 삭제할 수 없다면 그 메서드를 그대로 두고 deprecated로 표시한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 매개변수 추가
*메서드가 자신을 호출한 부분의 정보를 더 많이 알아야 할 땐 객체에 그 정보를 전달할 수 있는 매개변수를 추가한다.*
##### 동기
매개변수 추가는 흔히 사용되는 리팩토링 기법이라서 웬만한 사람은 사용해본 적이 있을 것이다. 메서드를 수정해야 하는데 이 과정에서 기존에 전달하지 않은 정보가 필요할 땐 이 정보를 전달하고자 매개변수를 추가해야 한다.

매개변수를 추가하는 대신 다른 방법을 사용할 수 있을 때도 많은데, 그럴 땐 가능하면 그런 대안을 사용하는게 낫다. 매개변수를 추가하면 매개변수 세트가 더 길어지기 때문이다. 매개변수 나열이 길수록 기억하기도 힘들고 데이터 뭉치라는 구린내가 날 가능성이 높아서 좋지 않다.
##### 방법
* 메서드 시그너처가 상위클래스나 하위클래스에 구현되어 있는지 검사한다. 구현되어 있다면 이 과정을 모든 구현부마다 실시한다.
* 추가한 매개변수를 전달받는 새 메서드를 선언한다. 원본 메서드의 내용을 새 메서드로 복사한다.
  * 매개변수를 둘 이상 추가해야 할 때는 한꺼번에 추가하는 것이 더 간편하다.
* 컴파일한다.
* 새 메서드를 호출하게 원본 메서드의 내용을 수정한다.
  * 참조하는 부분이 별로 없다면 이 단계를 건너뛰어도 된다.
  * 새 매개변수에 어떤 값이든 전달해도 되지만, 보통 객체 매개변수엔 null을 전달하고 내장 타입엔 명백히 이상한 값을 전달해서 참조하는 부분을 찾아낸다. 이런 경우를 쉽게 찾으려면 숫자응 0이 아닌 값을 전달하는 것이 좋다.
* 컴파일과 테스트를 실시한다.
* 원본 메서드 참조 부분을 전부 찾아서 새 메서드 참조로 바꾼다. 수정할 때마다 테스트를 실시한다.
* 원본 메서드를 삭제한다.
  * 원본 메서드가 인터페이스에 들어 있고 그 메서드의 모든 호출 부분에 접근할 수 없다면 원본 메서드는 그대로 놔두고 deprecated로 표시한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 매개변수 제거
*메서드가 어떤 매개변수를 더 이상 사용하지 않을 땐 그 매개변수를 삭제한다.*
##### 동기
매개변수는 필요한 정보를 나타낸다. 매개변수로 다른 값이 전달되면 결과가 달라진다. 호출 부분에서는 무슨 값을 전달할지 신중해야 한다. 매개변수를 제거하지 않으면 그 메서드를 사용하는 모든 곳이 불필요한 추가 작업을 수행하게 된다.

이때 재정의 메서드에 주의해야 한다. 그 메서드의 다른 재정의 메서드에서 매개변수가 사용되진 않는지 살펴봐야 한다. 그런 상황에 사용 가능한 별도의 메서드를 추가로 작성할 수도 있지만, 호출 부분에서 그 메서드가 어떤 식으로 사용되는지 검사해서 그렇게 할 가치가 있는지부터 판단해야 한다.

만약 재정의 메서드가 특정 하위클래스를 처리하고 매개변수를 찾는 부가 작업을 수행한다는 사실이나 null이 되지 않게 할 수 있음을 클래스 계층 정보를 통해 알고 있다는 사실을 일부 호출 코드가 이미 알고 있다면, 매개변수 없는 메서드를 하나 추가한다. 호출 코드가 어느 클래스에 어느 메서드가 있는지 알 필요 없다면 호출 코드를 그대로 둬야 한다. 
##### 방법
* 메서드 시그너처가 상위클래스나 하위클래스에 구현되어 있는지 검사한다. 하위클래스나 상위클래스가 제거하려는 매개변수를 사용하는지 검사해서 사용한다면 이 리팩토링은 하지 말아야 한다.
* 제거할 매개변수가 없는 새 메서드를 선언한다. 원본 메서드의 내용을 새 메서드로 복사한다.
  * 매개변수를 둘 이상 제거해야 할 때는 한꺼번에 제거하는 것이 편리하다.
* 컴파일한다.
* 새 메서드를 호출하도록 원본 메서드의 내용을 수정한다.
  * 참조 부분이 별로 없다면 이 단계를 건너뛰어도 된다.
* 컴파일과 테스트를 실시한다.
* 원본 메서드 참조 부분을 전부 찾아서 새 메서드 참조로 수정한다. 수정할 때마다 테스트를 실시한다.
* 원본 메서드를 삭제한다.
  * 원본 메서드가 인터페이스에 들어 있고 그 메서드의 어느 호출 부분에도 접근할 수 없다면, 원본 메서드를 그대로 두고 deprecated로 표시한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 상태 변경 메서드와 값 반환 메서드를 분리
*값 반환 기능과 객체 상태 변경 기능이 한 메서드에 들어 있을 땐 질의 메서드와 변경 메서드로 분리한다.*
##### 동기
값을 반환하며 눈에 띄는 부작용이 없는 함수를 작성했다면 그 함수는 높은 가치가 있다. 그런 함수는 필요할 때마다 몇 번이든 호출할 수 있으며, 그런 함수를 호출하는 코드는 메서드 안의 다른 위치로 옮길 수 있다. 간단히 말해 그런 함수를 사용하면 개발자가 신경 쓸 일이 훨씬 줄어든다.

부작용 있는 메서드와 부작용 없는 메서드의 차이를 명확히 분간하는 것이 좋다. 값을 반환하는 모든 메서드는 눈에 띄는 부작용이 없어야 한다는 규칙을 따르는 것이 좋다.

값을 반환한느 메서드가 있는데 그 메서드에 부작용이 있다면 상태 변경 부분과 값 반환 부분을 별도의 메서드로 각각 분리해야 한다.
##### 방법
* 원본 메서드와 같은 값을 반환하는 값 반환 메서드를 작성한다.
  * 원본 메서드를 관찰하여 무엇을 반환하는지 알아낸다. 반환된 값이 임시적이면 임시 할당 위치를 살펴본다.
* 메서드 호출의 결과를 반환하게 원본 메서드를 수정한다.
  * 원본 메서드 안의 모든 return 문은 다른 것을 반환하게 작성하지 말고 return newQuery() 라고 작성해야 한다.
  * 원본 메서드가 반환 값을 임시변수에 한 번 할당한다면, 그 임시변수를 제거할 수 있어야 한다.
* 컴파일과 테스트를 실시한다.
* 각 호출에 대해 한 번의 원본 메서드 호출을 값 반환 메서드 호출로 수정한다. 값 반환 메서드 호출행 앞에 원본 메서드 호출을 추가한다. 호출 메서드를 하나 수정할 때마다 테스트한다.
* 원본 메서드를 void 타입으로 수정하고 안의 return 문을 삭제한다.
###### 병행처리 문제
멀티스레딩 시스템에서는 테스트와 설정 연산 수행을 한 번에 실시하는 것이 중요하다. 값 반환 메서드와 상태 변경 메서드를 반드시 분리해야 한다는 점엔 변함이 없다. 다만 두 기능을 모두 수행하는 제 3의 메서드를 두어야 한다. 질의 겸 상태 변경 메서드는 질의 메서드와 상태 변경 메서드를 호출하고 동기화한다. 질의 메서드와 상태 변경 메서드가 동기화되지 않을 경우, 두 메서드의 개방도를 패키지 수준이나 private 수준으로 제한해야 한다. 그렇게 하면 두 개의 이해하기 쉬운 메서드로 분리된 기능이 안전하면서도 동기화된 상태가 된다. 이로써 이 두 개의 저수준 메서드는 다른 용도로도 사용 가능하다.
<hr/>

### 메서드를 매개변수로 전환
*여러 메서드가 기능은 비슷하고 안에 든 값만 다를 땐 서로 다른 값을 하나의 매개변수로 전달받는 메서드를 하나 작성한다.*
##### 동기
기능은 비슷하지만 몇 가지 값에 따라 결과가 달라지는 메서드가 여러 개 있을 때 각 메서드를 전달된 매개변수에 따라 다른 작업을 처리하는 하나의 메서드로 만들면 편리하다. 그렇게 수정하면 중복 코드가 없어지고 매개변수 추가를 통해 다양한 것을 처리할 수 있어서 유연성도 커진다.
##### 방법
* 여러 메서드를 대체할 수 있는 매개변수 메서드를 작성한다.
* 컴파일한다.
* 새 메서드를 호출하도록 원본 메서드 하나를 수정한다.
* 컴파일과 테스트를 실시한다.
* 모든 메서드를 대상으로 앞의 절차를 반복 실시하면서 테스트한다.

앞의 절차를 메서드 전반에 적용할 순 없고 메서드의 일부분에만 적용 가능할 때도 있다. 그럴 땐 우선 그 부분을 별도의 메서드로 빼낸 후 그 메서드에 매개변수를 추가한다.
<hr/>

### 매개변수를 메서드로 전환
*매개변수로 전달된 값에 따라 메서드가 다른 코드를 실행할 땐 그 매개변수로 전달될 수 있는 모든 값에 대응하는 메서드를 각각 작성한다.*
```
void setValue (String name, int value) {
  if (name.equals("height")) {
    _height = value;
    return;
  }
  if (name.equals("width")) {
    _width = value;
    return;
  } Assert.shouldNeverReachHere();
}
```
```
void setHeight(int arg) {
  _height = arg;
}
void setWidth (int arg) {
  _width = arg;
}
```
##### 동기
매개변수를 메서드로 전환은 메서드를 매개변수로 전환의 작업 절차를 거꾸로 하면 된다. 이 리팩토링 기법은 일반적으로 한 매개변수의 값이 여러 개가 될 수 있을 때 조건문 안에서 각 값을 검사하여 다른 기능을 수행하는 메서드에 적용하게 된다. 호출하는 부분은 매개변수에 값을 지정하여 무엇을 수행할지 판단해야 하므로, 여러 메서드를 작성하고 조건문은 없애는 것이 좋다. 그러면 조건에 따른 실행도 방지하면서 컴파일할 때 검사가 된다는 장점이 있다. 더군다나 인터페이스도 더 명료해진다. 그 메서드를 사용하는 프로그래머는 클래스에서 그 메서드가 사용된 부분을 관찰하고 유효한 매개변수 값도 알아내야 한다. 유효한 매개변수 값을 알아내는 방법을 제대로 설명한 문서는 거의 없다.

컴파일할 때의 검사는 불필요할 때도 있겠지만 인터페이스의 명료성은 언제나 큰 장점이다. Switch.beOn() 메서드가 Switch.setState(true) 메서드에 비해 훨씬 이해하기 쉬운데다가 메서드 안의 부울값(boolean) 필드를 설정하기만 하면 되기 때문이다.

매개변수 값이 많이 변할 가능성이 있을 때는 매개변수를 개별 메서드로 전환을 실시하면 안 된다. 이럴 때 필드를 그냥 전달받은 매개변수로 지정하려면 간단한 속성 쓰기 메서드를 사용하면 된다. 조건에 따라 다른 동작을 실행하게 해야 할 때는 조건문을 재정의로 전환을 실시해야 한다.
##### 방법
* 매개변수의 각 값에 해당하는 개별 메서드를 작성한다.
* 조건문의 각 절마다 해당되는 새 메서드 호출을 넣는다.
* 각 절을 수정할 때마다 테스트를 실시한다.
* 조건문이 든 원본 메서드의 각 호출 부분을 알맞은 새 메서드 호출로 바꾼다.
* 컴파일과 테스트를 실시한다.
* 호출 부분을 전부 고쳤으면 조건문이 든 매개변수 메서드를 삭제한다.
<hr/>

### 객체를 통째로 전달
*객체에서 가져온 여러 값을 메서드 호출에서 매개변수로 전달할 땐 그 객체를 통째로 전달하게 수정한다.*
```
int low = daysTempRange().getLow();
int high = daysTempRange().getHigh();
withinPlan = plan.withinRange(low, high);
```
```
withinPlan = plan.withinRange(daysTempRange());
```
##### 동기
객체가 한 객체에 든 여러 값을 메서드 호출할 때 매개변수로 전달하고 있다면 이 리팩토링 기법을 적용해야 한다. 이럴 땐 호출된 객체가 나중에 새 데이터 값을 필요로 할 때마다 이 메서드를 호출하는 모든 부분을 찾아서 수정해야 한다는 문제가 있다. 데이터를 넘겨주는 객체 자체를 통째로 넘기면 이 문제를 방지할 수 있다. 이렇게 하면 호출된 객체는 넘겨주는 객체로부터 필요한 것을 무엇이든 요청할 수 있다.

객체를 통째로 전달을 실시하면 매개변수 세트 변경의 편의성뿐 아니라 코드를 알아보기도 쉬워진다. 매개변수 나열이 길면 호출하는 부분과 호출되는 부분에서 어느 값들이 거기 있었는지를 전부 기억해야 하므로 작업이 힘들어질 수 있다. 게다가 호출되는 객체가 데이터를 넘겨주는 객체를 통째로 넘겼더라면 사용할 수 있었을 다른 메서드를 이용할 수 없으므로 중복 코드가 생긴다.

객체를 통째로 전달하는 방식에도 단점은 있다. 값을 전달할 때 호출되는 객체가 그 값들에 의존하게 되지만 값이 추출된 객체에는 의존하지 않게 된다는 점이다. 통 객체를 전달하면 통 객체와 호출된 객체가 서로 의존하게 된다. 이것이 의존성 구조를 망가뜨릴 것 같으면 객체를 통째로 전달을 실시하지 말아야 한다.

호출하는 객체가 통 객체에서 가져올 값이 하나뿐이라면 통 객체를 전달하는 것보다 그 값 하나만 전달하는 것이 효율적이라서 객체를 통째로 전달을 실시하지 말아야 한다는 얘기가 있는데 적어도 코드의 명료성 측면에선 값 하나를 넘기나 객체 하나를 넘기나 마찬가지다. 다만, 매개변수로 값을 전달하면 성능이 떨어질 수 있다. 이 리팩토링 기법의 문제는 종속성이 생긴다는 점이다.

호출된 메서드가 다른 객체에 있는 많은 값을 사용한다면, 호출된 메서드는 사실상 그 값들을 넘겨주는 객체에 정의해야 한다. 객체를 통째로 전달의 실시 여부를 고민 중이라면 대안으로 메서드 이동을 고려해본다.

통째로 전달할 객체를 아직 정의하지 않았을 땐, 매개변수 세트를 객체로 전환을 실시해야 한다.

호출하는 객체가 자체의 데이터 값 여러 개를 매개변수로 전달하는 코드를 흔히 보게 된다. 이럴 땐 적절한 속성 접근 데이터가 있고 의존성에 대한 걱정이 없다면, 호출하면서 여러 개의 데이터 값 대신 this를 전달하면 된다.
##### 방법
* 데이터가 속한 통째로 전달할 객체에 새 매개변수를 작성한다.
* 컴파일과 테스트를 실시한다.
* 통째로 전달할 객체에서 가져와야 할 매개변수를 파악한다.
* 한 매개변수를 선택해서 메서드 안에서 그 매개변수를 참조하는 부분을 넘겨받은 통째로 전달할 객체 안의 적절한 메서드 호출로 바꾼다.
* 그 매개변수를 삭제한다.
* 컴파일과 테스트를 실시한다.
* 통째로 전달할 객체에서 가져올 수 있는 모든 매개변수를 대상으로 위의 과정을 반복한다.
* 삭제한 매개변수들을 가져오는 호출 메서드 안의 코드를 삭제한다.
  * 당연한 얘기지만, 이 매개변수들이 코드의 다른 곳에 전혀 사용되지 않을 때만 수행한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 매개변수 세트를 메서드로 전환
*객체가 A 메서드를 호출해서 그 결과를 B 메서드에 매개변수로 전달하는데, 결과를 매개변수로 받는 B 메서드도 직접 A 메서드를 호출할 수 있을 땐 매개변수를 없애고 A 메서드를 B 메서드가 호출하게 한다.*
```
int basePrice = _quantity * _itemPrice;
discountLevel = getDiscountLevel();
double finalPrice = discountedPrice (basePrice, discountLevel);
```
```
int basePrice = _quantity * _itemPrice;
double finalPrice = discountedPrice (basePrice);
```
##### 동기
메서드가 매개변수로 전달받는 값을 다른 방법으로도 가져올 수 있다면, 그 방법을 택해야 한다. 매개변수 나열이 길면 코드가 복잡해지므로 가능하면 매개변수를 줄여야 한다.

전달할 매개변수를 줄이려면 같은 계산을 수신 메서드도 할 수 있는지 검사해야 한다. 객체가 자신의 메서드를 호출하지만 호출한 메서드의 매개변수가 계산에 전혀 사용되지 않는다면, 그 계산을 별도의 메서드로 만들고 매개변수를 삭제할 수 있다. 호출하는 객체를 참조하는 다른 객체에 있는 메서드를 호출할 때도 마찬가지다.

호출한 메서드의 매개변수가 계산에 사용될 땐 매개변수를 삭제하면 안 된다. 왜냐하면 그 매개변수는 호출이 일어날 때마다 변할 수 있기 때문이다. 이건 그 매개변수가 메서드로 교체할 수 없을 때만 해당된다. 결과 수신 메서드에 결과 송신 메서드 호출 코드가 들어 있지 않고 호출 코드를 전혀 추가할 생각이 없더라도 매개변수를 삭제하면 안 된다.

나중에 메서드를 매개변수 메서드로 바꿀 가능성에 대비해 매개변수를 두는 경우가 가끔 있다. 그럴 때도 매개변수는 없애는 것이 좋다. 매개변수를 메서드로 바꾸는 작업은 필요할 때만 한다. 심지어 필요할 때조차 매개변수는 있어서 좋을 게 없다는 걸 깨달을 것이다. 인터페이스 수정으로 인해 프로그램 여기저기에 삽입된 코드 중 상당 부분을 수정해야 하는 등의 끔찍한 결과에 처하게 될 때만 예외적으로 매개변수를 사용하게 내버려두는 것이 좋다. 수정 결과를 그토록 끔찍하게 만드는 종속성을 줄일 수 있는지 여부도 조사해야 한다. 인터페이스가 안정적인 건 좋지만, 그렇다고 해서 문제 있는 인터페이스를 방치하는 건 문제다.
##### 방법
* 필요하다면 매개변수를 사용한 계산 부분을 별도의 메서드로 빼낸다.
* 메서드 안의 매개변수 사용 부분을 추출한 메서드 호출로 수정한다.
* 하나씩 수정할 때마다 컴파일과 테스트를 실시한다.
* 매개변수를 대상으로 매개변수 제거를 실시한다.
<hr/>

### 매개변수 세트를 객체로 전환

