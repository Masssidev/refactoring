# 조건문 간결화
조건문은 복잡해질 가능성이 높은 만큼, 복잡한 조건문을 간소화하는 리팩토링 기법도 다양하다.
<hr/>

### 조건문 쪼개기
*복잡한 조건문(if-then-else)이 있을 땐 if, then, else 부분을 각각 메서드로 빼낸다.*
```
if (date.before (SUMMER_START) || date.after(SUMMER_END))
  charge = quantity + _winterRate + _winterServiceCharge;
else charge = quantity * _summerRate;
```
```
if (notSummer(date))
  charge = winterCharge(quantity);
else charge = summerCharge(quantity);
```
##### 동기
프로그램에서 가장 복잡한 부분은 주로 복잡한 조건문이다. 조건을 검사하고 다양한 조건에 따라 다른 작업을 처리하는 코드를 작성하다 보면 금방 메서드가 길어진다. 메서드는 길어지기만 해도 알아보기 힘든데, 조건문까지 많으면 더 심각하다. 조건 검사 코드와 그에 따른 액션 코드를 보고 원리는 알 수 있지만, 왜 그렇게 되는지를 알기 힘들어서 주로 문제가 된다.

긴 코드가 다 그렇듯, 큰 덩어리의 코드를 잘게 쪼개고 각 코드 조각을 용도에 맞는 이름의 메서드 호출로 바꾸면 코드의 용도가 분명히 드러난다. 이 과정을 조건문의 if 절, then 절, else 절 각각에 대해 수행하면 더 큰 장점을 얻을 수 있다. 즉, 조건이 눈에 잘 들어오고 갈라지는 로직 흐름을 알아보기 쉽다. 게다가 로직을 왜 그렇게 갈라놨는지도 확실히 알 수 있다.
##### 방법
* if 절을 별도의 메서드로 빼낸다.
* then 절과 else 절을 각각의 메서드로 빼낸다.
조건문이 여러 겹일 땐 먼저 여러 겹의 조건문을 감시 절로 전환기법부터 실시한다. 그 결과가 만족스럽지 않으면 조건문을 쪼갠다.
<hr/>

### 중복 조건식 통합
*여러 조건 검사식의 결과가 같을 땐 하나의 조건문으로 합친 후 메서드로 빼낸다.*
```
double disabilityAmount() {
  if (_seniority <2) return 0;
  if (_monthsDisabled > 12) return 0;
  if (_isPartTime) return 0;
  // 장애인 공제액 산출
}
```
```
double disabilityAmount() {
  if (isNotEligableForDisability()) return 0;
  // 장애인 공제액 산출
}
```
##### 동기
서로 다른 여러 개의 조건 검사식이 있는데 조건에 따른 결과가 모두 같을 때가 간혹 있다. 이럴 때는 논리연산자 AND와 OR을 사용해서 여러 조건 검사를 하나로 합쳐야 한다.

###### 조건문 코드를 합쳐야 하는 이유
1. 조건식을 합치면 여러 검사를 OR 연산자로 연결해서 실제로 하나의 검사 수행을 표현해서 무엇을 검사하는지 더 확실히 이해할 수 있다.
2. 조건식 통합 리팩토링 기법을 실시하면 메서드 추출을 적용할 수 있는 기반이 마련된다. 조건식을 메서드로 추출하면 처리 중인 기능의 상태를 표현하던 코드가 기능 수행 목적을 표현하는 코드로 바뀐다.

조건 검사식이 독립적이고 하나의 검사로 인식되지 말아야 할 땐 이 리팩토링 기법을 실시하면 안 된다. 
##### 방법
* 모든 조건문에 부작용이 없는지 검사한다.
  * 하나라도 부작용이 있으면 이 리팩토링 기법을 실시할 수 없다.
* 여러 개의 조건문을 논리 연산자를 사용해 하나의 조건문으로 바꾼다.
* 컴파일과 테스트를 실시한다.
* 합친 조건문에 메서드 추출적용을 고려한다.
##### 예제
* AND, OR, NOT 연산자를 사용하면 여러 조건문을 하나의 조건식으로 연결할 수 있다. 단, 이렇게 하면 조건식이 복잡해질 수 있으니 합친 조건식에 메서드 추출을 적용해서 간단히 만드는 게 좋다.
* 조건식 안의 루틴이 단순히 조건을 검사해서 값을 반환할 땐 삼항연산자를 사용해서 그 루틴을 한 줄의 return 문으로 만든다.
<hr/>

### 조건문의 공통 실행 코드 빼내기
*조건문의 모든 절에 같은 실행 코드가 있을 땐 같은 부분을 조건문 밖으로 빼낸다.*
```
if(isSpecialDeal()) {
  total = price * 0.95;
  send();
}
else {
  total = price * 0.98;
  send();
}
```
```
if(isSpecialDeal())
  total = price * 0.95;
else
  total = price * 0.98;
send();
```
##### 동기
조건문의 절마다 같은 실행 코드가 들어 있을 때가 있다. 이럴 땐 그 부분을 조건문 밖으로 빼야 한다. 그래야 각 절이 공통적으로 실행할 기능과 서로 다르게 실행할 기능을 한눈에 알 수 있다.
##### 방법
* 조건에 상관없이 공통적으로 실행되는 코드를 찾는다.
* 공통 코드가 조건문의 앞 절에 있을 땐 조건문 앞으로 뺀다.
* 공통 코드가 조건문의 끝 절에 있을 땐 조건문 뒤로 뺀다.
* 공통 코드가 조건문의 중간 절에 있을 땐 앞뒤의 코드와 위치를 바꿔도 되는지 판단한다. 그래서 바꿔도 된다면 조건문의 앞이나 끝 절로 뺀 후 앞의 단계처럼 조건문 앞이나 뒤로 뺀다.
* 공통 코드 명령이 둘 이상일 땐 메서드로 만든다.
##### 예제
예외 처리에도 이 방식을 적용할 수 있다. 코드가 try 구간과 모든 catch 구간 안의 예외 발생 명령 뒤에 공통적으로 들어 있으면, 그 코드를 final 구간으로 옮기면 된다.
<hr/>

### 제어 플래그 제거
*논리 연산식의 제어 플래그 역할을 하는 변수가 있을 땐 그 변수를 break 문이나 return 문으로 바꾼다.*
##### 동기
여러 조건문이 사용된 코드에는 다음과 같이 조건문을 빠져나갈 시점을 결정하는 제어 플래그가 흔히 사용된다.
```
done 변수에 false 값 할당
while done이 false인 동안
  if (조건식)
    뭔가 기능을 수행
    done 변수에 true 값 할당
  루프의 다음 단계로 넘어감
```
제어 플래그는 유용함을 능가하는 단점이 있다. 진입점과 이탈점이 하나씩 있는 루틴을 호출하는 구조적 프로그래밍의 문법적 잔재다. 물론 진입점이 하나인 것엔 문제가 없지만 이탈점을 하나만 사용하면 코드 안의 각종 특이한 플래그로 인해 조건문이 복잡해진다. 그래서 프로그래밍 언어엔 복잡한 조건문을 방지하는 break 문과 continue 문이 있다. 제어 플래그를 없애면 의외로 많은 것을 할 수 있고 조건문의 진정한 의도를 쉽게 파악할 수 있다. 
##### 방법
* 자바에서는 다음과 같이 break 문이나 continue 문으로 제어 플래그를 확실히 없앨 수 있다.
  * 논리문을 빠져나오게 하는 제어 플래그 값을 찾는다.
  * 그 제어 플래그 값을 대입하는 코드를 break 문이나 continue 문으로 바꾼다.
  * 하나씩 바꿀 때마다 컴파일과 테스트를 실시한다.
* return 을 이용
  * 로직을 메서드로 빼낸다.
  * 논리문을 빠져나오게 하는 제어 플래그 값을 찾는다.
  * 빠져나오게 하는 값을 return 문으로 바꾼다.
  * 하나씩 바꿀 때마다 컴파일과 테스트를 실시한다.
  
메서드 추출 후 return 문으로 바꾸는 방법을 권장한다. return 문은 메서드 안에서 맨 끝에 있기 마련이므로, return 문을 넣으면 그 뒤에 더 이상 실행할 코드가 없음을 분명히 나타낼 수 있다. 대체로 return 문을 사용할 수 있는 코드가 있으면 무슨 수를 써서라도 그 부분을 메서드로 추출해야 한다.

제어 플래그가 결과 정보를 나타내는 역할도 하는지 살펴본다. 그럴 경우 break 문으로 수정했다면 제어 플래그는 여전히 필요하다. 그렇지 않고 메서드를 추출했다면 return 문으로 값을 반환하면 된다.
<hr/>

### 여러 겹의 조건문을 감시 절로 전환
*메서드에 조건문이 있어서 정상적인 실행 경로를 파악하기 힘들 땐 모든 특수한 경우에 감시 절을 사용한다.*
```
double getPayAmount() {
  double result;
  if (_isDead) result = deadAmount();
  else {
    if (_isSeparated) result = separatedAmount();
    else {
      if (_isRetired) result = retiredAmount();
      else result = normalPayAmount();
    };
  }
  return result;
};
```
```
double getPayAmount() {
  if (_isDead) return deadAmount();
  if (_isSeparated) return separatedAmount();
  if (_isRetired) return retiredAmount();
  return normalPayAmount();
};
```
### 동기
조건식은 주로 두 가지 형태를 띤다.
1. 어느 한 경로가 정상적인 동작의 일부인지 검사하는 형태
2. 조건식 판별의 한 결과만 정상적인 동작을 나타내고 나머지는 비정상적인 동작을 나타내는 형태

이런 조건문에는 다양한 의도가 있는데, 그 의도는 코드에 반영되어 드러나야 한다. 만약 둘다 정상 동작의 일부분이라면 if 절과 else 절로 구성된 조건문을 사용하고, 조건문이 특이한 조건이라면 그 조건을 검사해서 조건이 true일 경우 반환한다. 이런 식의 검사를 감시 절이라고 한다.

여러 겹의 조건문을 감시 절로 전환기법의 핵심은 강조 부분이다. if-then-else 문을 사용하면 if 절과 else 절의 비중이 동등하다. 따라서 코드를 보는 사람은 if 절과 else 절의 비중이 같다고 판단하게 된다. 그와 달리, 감시 절은 "이것은 드문 경우이니 이 경우가 발생하면 작업을 수행한 후 빠져나와라"하고 명령한다.

메서드에 진입점과 이탈점이 하나씩만 있다고 배운 프로그래머와 공동으로 작업할 때는 주로 여러 겹의 조건문을 감시 절로 전환기법을 사용한다. 유일한 진입점은 현대의 프로그래밍 언어에 표준처럼 굳어졌지만, 유일한 이탈점 규칙은 별로 바람직하지 않다. 코드의 명확성이 드러나는 것이 가장 중요하다. 메서드에 이탈점을 하나만 사용해서 더 명확해진다면 그렇게 해야겠지만, 그렇지 않을 때는 굳이 한 개의 이탈점을 고집할 필요가 없다.
##### 방법
* 조건 절마다 감시 절을 넣는다.
  * 그 감시 절은 값을 반환하거나 예외를 통지한다.
* 각 조건 절을 감시 절로 바꿀 때마다 컴파일과 테스트를 실시한다.
  * 모든 감시 절의 결과가 같다면 중복 조건식 통합기법을 실시한다.
##### 예제
여러 겹의 조건문 코드는 주로 메서드에 이탈점이 하나라고 배운 프로그래머들이 작성하는 경향이 있다. 메서드에 더 이상 중요한 작업이 남아 있지 않다면, 그 메서드를 빠져나오게 해서 관심이 없음을 나타내야 한다. 빈 else 문을 놔두면 코드를 보는 이에게 혼란을 줄 뿐이다.
<hr/>

### 조건문을 재정의로 전환
*객체 타입에 따라 다른 기능을 실행하는 조건문이 있을 땐 조건문의 각 절을 하위클래스의 재정의 메서드 안으로 옮기고, 원본 메서드는 abstract 타입으로 수정한다.*
##### 동기
객체 관련 전문용어 중 가장 웅대한 표현은 다형성이다. 재정의의 본질은 타입에 따라 기능이 달라지는 여러 객체가 있을 때 일일이 조건문을 작성하지 않아도 다형적으로 호출되게 할 수 있다는 것이다.

그래서 분류 부호에 따라 다른 코드를 실행하는 switch 문이나 문자열에 따라 다른 코드를 실행하는 if-then-else 문은 객체지향 프로그램에서 별로 사용하지 않는다.

다형성 개념을 적용한 재정의 방식을 사용하면 많은 장점이 있다. 이런 조건문 덩어리가 프로그램의 여러 곳에 있을 때 가장 큰 효과를 볼 수 있다. 새 타입을 추가하려면 모든 조건문을 찾아서 수정해야 한다. 그러나 하위클래스를 사용하면 새 하위클래스를 작성하고 적당한 메서드만 넣으면 된다. 클래스 사용 부분은 그 하위클래스를 알 필요가 없어서 시스템 내부의 의존성이 줄어들고 수정이 쉬워진다.
##### 방법
조건문을 재정의로 전환기법을 적용하기 전에 필요한 상속 구조부터 만들어야 한다. 
###### 상속 구조를 만드는 방법
1. 분류 부호를 하위클래스로 전환을 적용한다.
2. 분류 부호를 상태/전략 패턴으로 전환을 적용한다.

하위클래스로 전환하는 방식이 제일 간단하므로 가능하면 그 기법을 사용한다. 그러나 객체가 생성된 후 분류 부호를 수정하면 분류 부호를 하위클래스나 상태/전략 패턴으로 바꿀 수 없다. 다른 이유로 이 클래스에 이미 하위클래스를 작성했다면, 상태/전략 패턴으로 전환하는 기법을 사용해야 한다. 여러 개의 case 문이 하나의 분류 부호 값에 따라 다른 코드를 실행할 땐 그 분류 부호를 대체할 하나의 상속 구조를 만들어야 한다.

이제 조건문을 재정의 클래스로 만들 차례다. 이것을 적용할 조건문은 switch-case 문이나 if문이다.
* 조건문이 메서드 코드의 일부라면 그 조건문을 따로 떼서 메서드 추출을 적용한다.
* 필요하다면 메서드 이동을 적용해서 조건문을 최상위 클래스로 옮긴다.
* 하위클래스 중 하나를 택해서 그 안에 조건문 메서드를 재정의하는 메서드를 작성한다. 조건문의 해당 절에 있는 코드를 그 하위클래스 메서드로 옮기고 적절히 수정한다.
  * 이를 위해 상위클래스의 일부 private 메서드를 protected로 수정해야 할 수도 있다.
* 컴파일과 테스트를 실시한다.
* 메서드로 복사해 넣은 조건문 안의 절은 삭제한다.
* 컴파일과 테스트를 실시한다.
* 조건문의 나머지 절의 코드도 마찬가지로 하위클래스 메서드 안으로 옮긴다.
* 상위클래스 메서드를 abstract 타입으로 만든다.
<hr/>

### Null 검사를 널 객체에 위임
*null 값을 검사하는 코드가 계속 나올 땐 null 값을 널 객체로 만든다.*
##### 동기
재정의의 본질은 어떤 종류인지를 객체에 일일이 물어서 그 응답에 따라 실행할 기능을 호출하는 것이 아니라, 묻지도 따지지도 않고 기능을 곧바로 호출하는 것이다. 객체는 타입에 따라 그에 맞는 기능을 수행한다. null 값이 저장된 필드가 있을 땐 재정의하면 비교적 이해하기 힘들다. 
###### 널 객체
널 객체를 사용할 때 잘못되는 경우는 거의 없다. 널 객체는 실제 객체와 똑같은 모든 메시지에 응답하므로 시스템은 웬만해서는 정상 작동한다. 잘못돼서 빠져나오는 부분이 없으므로 문제를 감지하거나 찾기가 힘들어질 때도 있다. 물론 객체를 검사하기 시작하면 곧바로 널 객체가 잘못된 위치에 있음을 알게 될 것이다. 

널 객체는 반드시 상수이며 절대로 변하지 않는다. 따라서 널 객체 구현에 싱글턴 패턴을 사용한다. 요청하면 항상 인스턴스가 하나만 생성된다.
##### 방법
* 원본 클래스 안에 널 객체 역할을 할 하위클래스를 작성한다. 원본 클래스와 널 클래스 안에 isNull 메서드를 작성한다. 원본 클래스의 isNull 메서드는 false를 반환해야 하고, 널 클래스의 isNull 메서드는 true를 반환해야 한다.
  * isNull 메서드를 넣을 Nullable 인터페이스를 작성하면 좋을 때도 있다.
  * 아니면, 검사 인터페이스로 null 여부를 검사하는 방법도 있다.
* 컴파일한다.
* 원본 객체에 요청하면 null을 반환할 수 있는 부분을 전부 찾는다. 그래서 그 부분을 널 객체로 바꾼다.
* 원본 타입의 변수를 null과 비교하는 코드를 전부 찾아서 isNull 호출로 바꾼다.
  * 원본 클래스와 클라이언트를 한 번에 하나씩 수정하고 그때마다 컴파일과 테스트를 실시하면 된다.
  * null이 나오지 말아야 할 곳에 null을 검사하는 어설션을 몇개 넣으면 좋다.
* 컴파일과 테스트를 실시한다.
* 클라이언트가 null이 아니면 한 메서드를 호출하고 null이면 다른 메서드를 호출하는 case 문을 전부 찾는다.
* 각 case 문마다 널 클래스 안의 해당 메서드를 다른 기응의 메서드로 재정의한다.
* 재정의 메서드를 사용하는 부분에서 조건문을 삭제하고 컴파일과 테스트를 실시한다.
<hr/>

### 어설션 넣기
*일부 코드가 프로그램의 어떤 상태를 전제할 땐 어설션을 넣어서 그 전제를 확실하게 코드로 작성한다.*
```
double getExpenseLimit() {
  // 비용 한도를 두든지, 주요 프로젝트를 정해야 한다.
  return (_expenseLimit != NULL_EXPENSE) ? _expenseLimit : _primaryProject.getMemberExpenseLimit();
}
```
```
double getExpenseLimit() {
  Assert.isTrue (_expenseLimit != NULL_EXPENSE || _primaryProject != null);
  return (_expenseLimit != NULL_EXPENSE) ? _expenseLimit : _primaryProject.getMemberExpenseLimit();
}
```
##### 동기
특정 조건이 참일 때만 코드의 일부분이 실행되는 경우가 많다. 이것은 제곱근 계산이 양수 입력 값에 대해서만 작동하는 것만큼이나 단순할 수도 있다. 객체를 사용할 때 적어도 하나의 필드엔 값이 들어 있다고 가정할 수 있다.

그런 전제는 대개 코드로 작성되어 있지 않고 알고리즘을 두루 살펴야 알 수 있고, 가끔은 주석으로 처리되어 있을 때도 있다. 이런 전제는 어설션을 넣어 명확히 드러나게 하는 것이 좋다.

어설션이란 항상 참으로 전제되는 조건문을 뜻한다. 어설션이 실패하면 그건 프로그래머가 오류를 범한 것이다. 그래서 어설션이 실패할 경우 반드시 예외를 통지하게 해야 한다. 시스템의 다른 부분에는 절대로 어설션이 사용되면 안 된다. 어설션은 대개 제품화 단계에서 삭제한다. 따라서 코드에서 어설션을 넣은 부분을 꼭 표시해둬야 한다. 

어설션은 의사소통과 디버깅에 도움을 준다. 어설션을 통해 개발자는 의사소통에서 코드가 전제하는 내용을 쉽게 이해할 수 있고, 디버깅할 때 좀 더 근원적인 버그를 잡아낼 수 있다. 자체 코드를 작성할 때는 디버깅 측면의 중요성은 줄어들지만, 의사소통 측면의 가치는 여전하다.
##### 방법
어설션은 시스템의 가동에 영향을 미치지 않으므로 어설션을 넣어도 기능은 변하지 않는다.
* 어떤 조건이 참으로 전제된다면 어설션을 넣어 그 전제를 드러낸다.
  * 어설션 기능을 사용할 수 있는 Assert 클래스를 작성한다.
  
어설션 남용에 주의한다. 코드 일부에서 참이라고 생각되는 모든 곳에 어설션을 넣지 말고, 반드시 참이 되어야 하는 곳에만 넣는다. 어설션을 남용하면 로직이 중복되어 유지보수가 힘들어질 우려가 있다. 어설션을 다루는 로직은 코드의 해당 부분을 검토하게 하므로 바람직하다. 코드가 어설션 없이 작동할 경우엔 어설션을 넣으면 오히려 코드만 복잡해져서 나중에 코드 수정이 힘들어질 수 있다.

어설션이 실패하더라도 코드가 작동하는지 항상 자문해보고 어설션 실패에도 코드가 돌아간다면 그 어설션은 삭제한다.

어설션 안에 중복 코드가 안 생기게 주의한다. 중복 코드의 구린내는 어설션 검사를 남용하는 것만큼이나 지독하다. 메서드 추출을 적극 실시해서 중복 코드를 없앤다.
##### 예제
* 어설션은 프로그램의 기능에는 전혀 영향을 주지 않는다. 조건 중 하나라도 참이 아니면 런타임 예외를 통지한다. 어설션은 뭔가가 잘못되는 상황에 더 가깝다 보니 간혹 버그 찾기에 도움이 되기도 한다. 그러나 그건 사소하고 부수적인 장점에 불과하다. 어설션의 주요 장점은 코드 원리와 전제를 파악하기 쉽게 해준다는 점이다.
* 어설션 안의 조건문에 메서드 추출을 실시해 중복 코드를 없애거나 조건문의 목적을 더 분명히 드러나게 할 수 있다.
* 어설션을 코드에 넣을 간단한 메커니즘이 없을 때가 많다는 단점이 있다. 어설션은 나중에 삭제하기 쉬워야 하다 보니 제품화 코드에서 성능에 영향을 미치지 못한다. 
* Assert 클래스엔 용도를 알기 쉬운 이름으로 된 각종 메서드가 들어 있어야 한다. 

