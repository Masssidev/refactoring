# 메서드 정리
리팩토링의 주된 작업은 코드를 포장하는 메서드를 적절히 정리하는 것이다. 거의 모든 문제점은 장황한 메서드로 인해 생긴다. 

메서드를 잘게 쪼개면 동작 원리를 이해하기가 훨씬 쉽다. 게다가 간혹 알고리즘을 더 명료하게 개선할 수 있다. 
<hr/>

### 메서드 추출
*어떤 코드를 그룹으로 묶어도 되겠다고 판단될 땐 그 코드를 빼내어 목적을 잘 나타내는 직관적 이름의 메서드로 만들어야 한다.*
```
void printOwing(double amount) {
  printBanner();
  
  //세부 정보 출력
  System.out.println ("name:" + _name);
  System.out.println ("amount" + amount);
}
```
```
void printOwing(double amount) {
  printBanner();
  printDetails(amount);
}

void printDetails(double amount) {
  System.out.println ("name:" + _name);
  System.out.println ("amount" + amount);
}
```
##### 동기
메서드 추출 기법은 제일 많이 사용된다. 메서드가 너무 길거나 코드에 주석을 달아야만 의도를 이해할 수 있을 때, 그 코드를 빼내어 별도의 메서드로 만든다.
###### 직관적인 이름의 간결한 메서드가 좋은 이유
1. 메서드가 적절히 잘게 쪼개져 있으면 다른 메서드에서 쉽게 사용할 수 있다.
2. 상위 계층의 메서드에서 주석 같은 더 많은 정보를 읽어들일 수 있다.
3. 재정의하기도 훨씬 수월하다.
> 중요한 것은 메서드명 길이가 아니라 메서드명과 메서드 내용의 의미적 차이다.

> 메서드 추출로 코드의 명료성이 향상되기만 한다면, 메서드명이 추출한 코드보다 길어도 메서드 추출을 실시해야 한다.
##### 방법
* 목적에 부합하는 이름의 새 메서드를 생성한다. 이때 메서드명은 원리가 아니라 기능을 나타내는 이름이어야 한다. 
  * 메서드로 빼낼 코드가 한 줄의 명령이나 함수 호출 같이 아주 간단한 것이라면 새 메서드명을 통해 그 코드의 기능(목적)을 더 잘 드러낼 수 있을 때만 추출을 실시한다. 더 이해하기 쉬운 이름으로 추출하지 않을 바에는 차라리 코드를 추출하지 않는다.
* 기존 메서드에서 빼낸 코드를 새로 생성한 메서드로 복사한다.
* 빼낸 코드에서 기존 메서드의 모든 지역변수 참조를 찾는다. 그것들을 새로 생성한 메서드의 지역 변수나 매개변수로 사용한다.
* 빼낸 코드 안에서만 사용되는 임시변수가 있는지 파악해서 있다면 그것들을 새로 생성한 메서드 안에 임시변수로 선언한다.
* 추출 코드에 의해 변경되는 지역변수가 있는지 파악한다. 만약 하나의 지역변수만 변경된다면 추출 코드를 메서드 호출처럼 취급할 수 있는지 알아내고 그 결과를 관련된 변수에 대입할 수 있는지 알아낸다. 이렇게 하기가 까다롭거나 둘 이상의 지역변수가 변경될 때는 메서드를 추출하기 위해 먼저 임시변수 분리등의 기법을 적용해야 할 수도 있다. 임시변수를 제거하려면 임시변수를 메서드 호출로 전환기법을 적용하면 된다.
* 빼낸 코드에서 읽어들인 지역변수를 대상 메서드에 매개변수로 전달한다.
* 모든 지역변수 처리를 완료했으면 컴파일을 실시한다.
* 원본 메서드 안에 있는 빼낸 코드 부분을 새로 생성한 메서드 호출로 수정한다.
  * 대상 메서드로 임시변수를 옮겼으면 그 임시변수가 원본 코드 외부에 선언되어 있었는지 검사해서, 그렇다면 대상 코드에서는 그 선언 부분을 삭제한다.
* 컴파일과 테스트를 실시한다. 
##### 예제
* 지역변수는 해당 메서드 안에서만 효력이 있으므로 메서드 추출을 적용하면 지역변수와 관련된 작업을 추가로 처리해야 한다. 간혹 지역변수 때문에 리팩토링이 아예 불가능할 때도 있다.
  * 지역변수 문제 중 제일 가벼운 경우는 지역변수가 읽히기만 하고 변경되지 않을 때다. 이럴 땐 지역변수를 그냥 매개변수로 전달한다.
  * 지역 변수가 객체이고 그 변수에서 쓰기 메서드를 호출할 때도 마찬가지다. 객체를 단순히 매개변수로 전달할 수 있다. 그 지역변수에 대입할 경우엔 약간의 다른 작업만 수행하면 된다.
* 복잡한 경우는 지역변수로의 값 대입이다. 이럴 때는 임시변수만 생각하면 된다. 매개변수로의 값 대입이 있을 경우엔 즉시 매개변수로의 값 대입 제거를 실시해야 한다.
  * 임시변수가 추출한 코드 안에서만 사용되는 경우에는, 간단히 임시변수를 추출한 코드로 옮기면 된다.
  * 임시변수가 추출한 코드 밖에서 사용되는 경우에는, 만약 그 임시변수가 코드가 추출된 후 사용되지 않는다면 추출한 코드에서 그 임시변수의 변경된 값을 반환하게 수정해야 한다. 
* 둘 이상의 변수를 반환해야 하는 경우에는 다른 부분의 코드를 빼낸다. 메서드가 하나의 값만 반환하도록 각기 다른 값을 하나씩 반환하는 여러 개의 메서드를 만든다.
* 간혹 임시 변수가 너무 많으면 추출하기가 아주 어려워질 수도 있다. 이럴 땐 임시 변수를 메서드 호출로 전환기법을 실시해서 임시변수의 수를 줄인다.
<hr/>

### 메서드 내용 직접 삽입
*메서드 기능이 너무 단순해서 메서드명만 봐도 너무 뻔할 땐 그 메서드의 기능을 호출하는 메서드에 넣어버리고 그 메서드는 삭제한다.*
```
int getRating() {
  return (moreThanFiveLateDeliveries()) ? 2 : 1;
}
boolean moreThanFiveLateDeliveries() {
  return _numberOfLateDeliveries > 5;
}
```
```
int getRating() {
  return (_numberOfLateDeliveries > 5) ? 2 : 1;
}
```
##### 동기
리팩토링의 핵심은 의도한 기능을 한눈에 파악할 수 있는 직관적인 메서드명을 사용하는 것과 메서드를 간결하게 만드는 것이다. 하지만 간혹 메서드명에 모든 기능이 반영될 정도로 메서드 기능이 지나치게 단순할 땐 메서드를 없애야 한다. 

메서드 내용 직접 삽입기법은 잘못 쪼개진 메서드에도 적용할 수 있다. 잘못 쪼개진 메서드의 내용을 전부 하나의 큰 메서드에 직접 삽입한 후, 합친 메서드에서 다시 각각의 작은 메서드로 추출하면 된다. 
##### 방법
* 메서드가 재정의되어 있지 않은지 확인한다.
  * 메서드가 하위클래스에 재정의되어 있다면 메서드 내용 직접 삽입을 실시하지 않는다. 없어진 메서드를 재정의하는 일이 생겨선 안되기 때문이다.
* 그 메서드를 호출하는 부분을 모두 찾는다.
* 각 호출 부분을 메서드 내용으로 교체한다.
* 테스트를 실시한다.
* 메서드 정의를 삭제한다.
<hr/>

### 임시변수 내용 직접 삽입
*간단한 수식을 대입받는 임시변수로 인해 다른 리팩토링 기법 적용이 힘들 땐 그 임시변수를 참조하는 부분을 전부 수식으로 치환한다.*
```
double basePrice = anOrder.basePrice();
return (basePrice > 1000)
```
```
return (anOder.basePrice() > 1000)
```
##### 동기
임시변수 내용 직접 삽입은 임시변수를 메서드 호출로 전환기법을 실시하는 도중에 병용하게 되는 경우가 태반이다. 임시변수 내용 직접 삽입은 임시변수를 메서드 호출로 전환을 실시해야 하는 동기라고 할 수 있다. 임시변수 내용 직접 삽입만 순수하게 사용되는 경우는 오직 메서드 호출의 결괏값이 임시변수에 대입될 때뿐이다. 이러한 임시변수는 별다른 문제가 없으므로 내버려둬도 된다. 하지만 만일 임시변수가 메서드 추출등 다른 리팩토링에 방해가 된다면 임시변수 내용 직접 삽입을 적용해야 한다.
##### 방법
* 대입문의 우변에 문제가 없는지 확인한다.
* 문제가 없다면 임시변수를 final로 선언하고 컴파일한다.
  * 이것으로 그 임시변수에는 값을 한 번만 대입할 수 있다.
* 그 임시변수를 참조하는 모든 부분을 찾아서 대입문 우변의 수식으로 바꾼다.
* 하나씩 수정을 마칠 때마다 컴파일과 테스트를 실시한다.
* 임시변수 선언과 대입문을 삭제한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 임시변수를 메서드 호출로 전환
*수식의 결과를 저장하는 임시변수가 있을 땐 그 수식을 빼내어 메서드로 만든 후, 임시변수 참조 부분을 전부 수식으로 교체한다. 새로 만든 메서드는 다른 메서드에서도 호출 가능한다.*
```
double basePrice = _quantity * _itemPrice;
if(basePrice > 1000)
  return basePrice * 0.95;
else
  return basePrice * 0.98;
```
```
if(basePrice() > 1000)
  return basePrice() * 0.95;
else
  return basePrice() * 0.98;
...
double basePrice() {
  return _quantity * _itemPrice;
}
```
##### 동기
임시변수는 일시적이고 적용이 국소적 범위로 제한된다는 단점이 있다. 임시변수는 자신이 속한 메서드의 안에서만 인식되므로, 그 임시변수에 접근하려다 보면 코드는 길어지게 마련이다. 임시변수를 메서드 호출로 수정하면 클래스 안 모든 메서드가 그 정보에 접근할 수 있다. 이렇게 하면 클래스의 코드가 훨씬 깔끔해진다.
##### 방법
* 값이 한 번만 대입되는 임시변수를 찾는다.
  * 값이 여러 번 대입되는 임시변수가 있으면 임시변수 분리기법 실시를 고려한다.
* 그 임시변수를 final로 선언한다.
* 컴파일을 실시한다.
  * 이것으로 임시변수엔 값을 한 번만 대입할 수 있다.
* 대입문 우변을 빼내어 메서드로 만든다.
  * 처음엔 메서드를 private로 선언한다. 그러다 나중에 더 여러 곳에서 사용하게 되면 접근 제한을 간단히 완화하면 된다.
  * 추출 메서드에 문제가 없는지(즉, 객체를 변경하진 않는지) 확인한다. 만약 객체 변경 등의 문제가 있다면 상태 변경 메서드와 값 반환 메서드를 분리기법을 실시한다.
* 컴파일과 테스트를 실시한다.
* 임시변수를 대상으로 임시변수 내용 직접 삽입기법을 실시한다.

임시변수는 루프 안에서 요약 정보를 저장하는 용도로 사용될 때가 많다. 루프 전체가 하나의 메서드로 추출되는 경우도 있는데, 이렇게 하면 지저분한 코드 몇 줄이 줄어든다. 
##### 예제
* 컴파일해서 문제가 있으면 임시변수를 메서드 호출로 전환하는 기법을 실시하지 말아야 한다.
* 임시변수를 한 번에 하나씩 메서드 호출로 바꾼다.
* 더 이상 임시 변수 참조 부분이 없으면 임시변수 선언을 삭제한다.
<hr/>

### 직관적 임시변수 사용
*사용된 수식이 복잡할 땐 수식의 결과나 수식의 일부분을 용도에 부합하는 직관적 이름의 임시변수에 대입한다.*
```
if ( (platform.toUpperCase().indexOf("MAC") > -1) && (browser.toUpperCase().indexOf("IE") > -1) && wasInitialized() && resize > 0 )
{ //기능 코드 }
```
```
final boolean isMacOs = platform.toUpperCase().indexOf("MAC") > -1;
final boolean isIEBrowser = browser.toUpperCase().indexOf("IE") > -1;
final boolean wasResized = resize > 0;

if (isMacOs && isIEBrowser && wasInitialized() && wasResized) {
  // 기능 코드
}
```
##### 동기
수식이 너무 복잡해져서 이해하기 힘들 수 있다. 이럴 때는 임시변수를 사용하면 수식을 더 처리하기 쉽게 쪼갤 수 있다.

직관적 임시변수 사용기법은 조건문에서 각 조건 절을 가져와서 직관적 이름의 임시변수를 사용해 그 조건의 의미를 설명하려 할 때 많이 사용한다. 그 외에 긴 알고리즘에서 임시변수를 사용해서 계산의 각 단계를 설명할 수 있을 때도 사용한다.

임시변수를 생각 없이 남용하면 안 된다. 관련 없는 임시변수를 사용하면 메서드만 복잡해지고 코드를 보는 사람이 이해하기 힘들어진다. 
##### 방법
* 임시 변수를 final로 선언하고, 복잡한 수식에서 한 부분의 결과를 그 임시변수에 대입한다.
* 그 수식에서 한 부분의 결과를 그 임시변수의 값으로 교체한다.
  * 수식의 결과 부분이 반복될 경우엔 한 번에 하나씩 교체하면 된다.
* 컴파일과 테스트를 실시한다.
* 수식의 다른 부분을 대상으로 위의 과정을 반복 실시한다.

메서드 추출 기법 사용을 선호한다. 직관적 임시변수 사용기법은 메서드 추출 기법 적용이 더 어렵거나 복잡할 때 사용한다. 알고리즘에 수많은 지역변수가 사용될 땐 대체로 메서드 추출을 쉽게 적용할 수 없다. 이럴 땐 직관적 임시변수 사용기법을 사용해서 코드가 돌아가는 원리를 이래하기 쉽게 만든다. 로직의 복잡함이 덜해지면 나중에 언제든 임시변수를 메서드 호출로 전환기법을 적용하면 된다. 결국 메서드를 메서드 객체로 전환기법을 사용해야 할 때도 임시변수는 역시 중요하다.
<hr/>

### 임시변수 분리
*루프 변수나 값 누적용 임시변수가 아닌 임시변수에 여러 번 값이 대입될 땐 각 대입마다 다른 임시변수를 사용한다.*
```
double temp = 2 * (_height + _width);
System.out.println (temp);
temp = _height * _width;
System.out.println (temp);
```
```
final double perimeter = 2* (_height + _width);
System.out.println (perimeter);
final double area = _height * _width;
System.out.println (area);
```
##### 동기
임시변수의 용도는 다양한데, 일부 용도로 사용하다 보면 임시변수에 값이 여러 번 대입될 때가 있다. 루프 변수의 값은 루프를 한 번 돌 때마다 바뀐다. 값 누적용 임시변수는 그 메서드 실행 중에 더해지는 일부 값을 누적한다. 

그 밖의 많은 임시변수는 긴 코드의 계산 결과를 나중에 간편히 참조할 수 있게 저장하는 용도로 사용된다. 이런 변수엔 값이 한 번만 대입되어야 한다. 값이 두 번 이상 대입된다는 건 그 변수가 메서드 안에서 여러 용도로 사용된다는 반증이다. 여러 용도로 사용되는 변수는 각 용도별로 다른 변수를 사용하게 분리해야 한다. 임시변수 하나를 두 가지 용도로 사용하면 코드를 분석하는 사람에게 혼동을 줄 수 있다.
##### 방법
* 선언문과 첫 번째 대입문에 있는 임시변수 이름을 변경한다.
  * 뒤에 나오는 대입 부분이 i = i + 수식 형태라면 i는 값 누적용 임시변수이므로 분리하면 안 된다. 값 누적용 임시변수에 주로 사용하는 플러스 기호 연산자의 기능은 덧셈, 문자열 연결, 스트림에 쓰기, 컬렉션에 첨가하기 등이 있다.
* 이름을 바꾼 새 임시변수를 final로 선언한다.
* 그 임시변수의 모든 참조 부분을 두 번째 대입문으로 수정한다.
* 두 번째 대입문에 있는 임시변수를 선언한다.
* 컴파일과 테스트를 실시한다.
* 각 대입문마다 차례로 선언문에서 임시변수 이름을 변경하고, 그 다음 대입문까지 참조를 수정하며 위의 과정을 반복한다.
<hr/>

### 매개변수로의 값 대입 제거
*매개변수로 값을 대입하는 코드가 있을 땐 매개변수 대신 임시변수를 사용하게 수정한다.*
```
int discount (int inputVal, int quantity, int yearToDate) {
  if (inputVal > 50) inputVal -= 2;
```
```
int discount (int inputVal, int quantity, int yearToDate) {
  int result = inputVal;
  if (inputVal > 50) result -= 2;
```
##### 동기
어떤 메서드에 foo 객체를 매개변수로 전달하면 '매개별수로의 값 대입'은 foo의 값을 다른 객체 참조로 변경한다는 의미다.

전달받은 매개변수에 다른 개체 참조를 대입하면 코드의 명료성도 떨어지고 '값을 통한 전달'과 '참조를 통한 전달'을 혼동하게 되기 때문이다.

자바에선 매개변수에 값을 대입해서는 안 된다.
##### 방법
* 매개변수 대신 사용할 임시변수를 선언한다.
* 매개변수로 값을 대입하는 코드 뒤에 나오는 매개변수 참조를 전부 임시변수로 수정한다.
* 매개변수로의 값 대입을 임시변수로의 값 대입으로 수정한다.
* 컴파일과 테스트를 실시한다.
  * 의미론이 참조를 통한 호출일 때는 호출한 메서드에서 매개변수가 계속 사용되는지 살펴본다. 그리고 매개변수 참조를 통한 호출이 몇 개나 이 메서드의 뒷부분에서 대입되고 사용되는지 확인한다. 하나의 값만 반환 값으로 전달하게 만든다. 반환 값이 둘 이상이면 그 데이터 뭉치를 객체로 전환하거나 별도의 메서드로 만들 수 있는지 살펴본다.
###### 자바에서 값을 통한 전달
자바에서 값을 통한 방식을 사용하면 코드가 뒤죽박죽된다.
<hr/>

### 메서드를 메서드 객체로 전환
*지역변수 때문에 메서드 추출을 적용할 수 없는 긴 메서드가 있을 땐 그 메서드 자체를 객체로 전환해서 모든 지역변수를 개체의 필드로 만든다. 그런 다음 그 메서드를 개체 안의 여러 메서드로 쪼개면 된다.*
```
class Order...
  double price() {
    double primaryBasePrice;
    double secondaryBasePrice;
    double tertiaryBasePrice;
    //긴 계산 코드;
    ...
  }
}
```
##### 동기
장환한 메서드에서 각 부분을 간결한 메서드로 빼내면 코드가 훨씬 이애하기 쉬워진다.

메서드 분해를 어렵게 만드는 것은 지역변수다. 지역변수가 많으면 메서드를 쪼개기 힘들 수 있다. 임시변수를 메서드 호출로 전환을 적용하면 이런 어려움이 어느 정도 해소되지만, 분해가 필요한 메서드를 분해할 수 없을 때도 있다. 이럴 땐 메서드 객체로 수정해야 한다.
##### 방법
* 전환할 메서드의 이름과 같은 이름으로 새 클래스를 생성한다.
* 그 클래스에 원본 메서드가 들어 있던 객체를 나타내는 final 필드를 추가하고 원본 메서드 안의 각 임시변수와 매개변수에 해당하는 속성을 추가한다.
* 새 클래스에 원본 객체와 각 매개변수를 받는 생성자 메서드를 작성한다.
* 새 클래스에 compute라는 이름의 메서드를 작성한다.
* 원본 메서드 내용을 compute 메서드 안에 복사해 넣자. 원본 객체에 있는 메서드를 호출할 땐 원본 객체를 나타내는 필드를 사용한다.
* 컴파일을 실시한다.
* 원본 메서드를 새 객체 생성과 compute 메서드 호출을 담당하는 메서드로 바꾼다.
> 인자를 전달할 걱정 없이 compute 메서드에서 손쉽게 메서드 추출기법을 실시할 수 있다.
<hr/>

### 알고리즘 전환
*알고리즘을 더 분명한 것으로 교체해야 할 땐 해당 메서드의 내용을 새 알고리즘으로 바꾼다.*
```
String foundPerson(String[] people) {
  for(int i=0; i<people.length; i++) {
    if(people[i].equals ("Don")) {
      return "Don";
    }
    if(people[i].equals ("John")) {
      return "John";
    }
    if(people[i].equals ("Kent")) {
      return "Kent";
    }
  }
  return "";
}
```
```
String foundPerson(String[] people) {
  List candidates = Arrays.asList(new String[] {"Don", "John", "Kent"});
  for (int i=0; i<people.length; i++)
    if(condidates.contains(people[i]))
      return people[i];
  return "";
}
```
##### 동기
어떤 목적을 달성하는 방법은 여러 가지가 있게 마련이다. 다만, 다른 방법에 비해 쉬운 방법이 있을 뿐이다. 알고리즘도 마찬가지다. 어떤 기능을 수행하기 위한 비교적 간단한 방법이 있다면 복잡한 방법을 좀 더 간단한 방법으로 교체해야 한다. 리팩토링은 복잡한 코드를 간단한 부분으로 쪼갤 수 있지만, 간혹 알고리즘을 전부 삭제하고 더 간단한 알고리즘으로 교체해야 하는 상황에 부딪힐 때도 있다. 

길고 복잡한 알고리즘은 수정하기 어려우므로, 우선 간단할 알고리즘으로 교체해야만 수정 작업이 편해진다. 
##### 방법
* 교체할 간결한 알고리즘을 준비한다. 컴파일을 실시한다.
* 새 알고리즘을 실행하면서 여러 번의 테스트를 실시한다. 모든 테스트 결과가 같으면 성공한 것이다.
* 결과가 다르게 나온다면, 기존 알고리즘으로 테스트와 디버깅을 실시해 비교한다.
  * 기존 알고리즘과 새 알고리즘을 대상으로 각 테스트 케이스를 실행하고 두 결과를 비교한다. 그렇게 하면 어느 테스트 케이스가 문제를 어떤 식으로 일으키는지 확인할 수 있다. 
