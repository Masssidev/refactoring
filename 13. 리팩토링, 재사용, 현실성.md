# 리팩토링, 재사용, 현실성
### 개발자가 리팩토링을 꺼리는 이유
* 리팩토링 방법을 몰라서
* 리팩토링의 장점은 오랜 시간이 흘러야 가시화될 테고, 그때가 되면 프로젝트 팀원도 아닐 텐데 공연히 리팩토링에 힘 뺄 필요 없어서
* 코드를 리팩토링하는 일은 추가적인 부담인데다, 월급은 새 기능을 추가하라고 주는 거지 리팩토링하라고 주는 건 아니라서
* 리팩토링하다가 괜히 멀쩡한 프로그램을 망가뜨릴까 걱정되서
###### 리팩토링은 어디에 어떻게 적용하나
자동화 도구는 유사성을 찾아주고 공통된 코드를 한 곳으로 옮기는 리팩토링 기법들도 제안한다. 이렇게 리팩토링 적용 대상을 찾을 수 있다. 어떤 리팩토링 기법을 적용할지는 개발자의 목적에 따라 다르다. 공통적인 이유는 새 기능을 더 쉽게 추가할 수 있게 프로그램 구조를 개선하기 위해서다.
* 프로그래머는 리팩토링해야 할 부분과 방법을 알고 나서야 비로소 코드를 리팩토링해야겠다고 생각하게 된다.
* 자동화 도구는 프로그램 구조를 분석해서 구조 개선에 도움이 될 리팩토링 기법들을 제시한다.
> 대부분의 연구 노하우가 그렇듯이, 도구와 기법도 사용할 때나 도움이 된다.

> 프로그래머는 코드를 리팩토링 할수록 더 깊고 넓게 이해하게 된다.
###### 단기적 목적 달성을 위한 리팩토링
리팩토링으로 얻을 수 있는 중장기적 효과를 설명하기란 비교적 쉽다. 그러나 단기 성과에 대해선 수많은 조직이 투자 집단 등의 비난을 받는 사례가 갈수록 늘고 있다.

단기적 효과로는 테스트로 찾은 공통 부분의 에러는 한 곳만 수정하면 된다는 점이다. 중기적 효과는 리팩토링 결과로 얻어진 추상화 덕택에 향후 다른 시스템을 정의하기가 쉬워진다. 공통 코드가 있으니 처음부터 새로 작성하는 것보단 쉽다. 
> 리팩토링하면 단기적인 긍정적 효과를 얻을 수 있고 소프트웨어의 수정과 유지보수가 간편해진다. 리팩토링은 목적이 아니고 수단이다. 개인이나 팀이 자신들의 소프트웨어를 개발하고 유지보수하는 방법은 다양한데, 그 중 하나가 리팩토링인 것이다.
###### 리팩토링의 추가 부담 줄이기
* 널려 있는 도구와 기술을 사용하면 신속하고 간편하게 리팩토링할 수 있다.
* 일부 객체지향 개발자의 경험상 리팩토링으로 인한 추가 부담은 프로그램의 각 개발 단계마다 줄어든 수고와 시간을 상쇄하고도 남는다.
* 리팩토링이 처음엔 서툴고 부담되는 작업으로 느껴질 수 있지만, 프로그램 개발 과정에 하나의 단계로 넣으면 안 해도 되는 번외 업무라는 생각은 사라지고 필수적인 작업으로 여겨진다.
###### 안전하게 리팩토링하기
복잡한 시스템을 개발하고 업그레이드해가는 조직의 입장에선 안전성만큼 주된 관심사도 없다. 

안전성이라는 개념은 정의하기 어렵다. 쉽게 정의하자면, 안전한 리팩토링은 프로그램을 고장내지 않는 리팩토링이다. 리팩토링 목적은 기능을 그대로 유지하면서 프로그램 구조만 바꾸는 것이므로, 프로그램은 리팩토링 후에도 리팩토링 전과 기능과 동작이 같아야 한다.

리팩토링을 안전하게 하기 위한 몇 가지 방법
* 자신의 코딩 능력에 신념을 갖는다.
* 자신이 놓친 에러는 컴파일러가 잡아서 처리하리란 믿음을 갖는다.
* 컴파일러마저 놓친 에러는 테스트 스위트가 잡아 처리하리란 신뢰를 갖는다.
* 테스트 스위트마저 놓친 에러는 코드 검수 단계에서 발견하리란 확신을 갖는다.

컴파일러, 테스트 스위트, 코드 검수, 엄격한 규칙을 따르는 코딩 방식이 모두 중요하긴 하지만, 모든 방법엔 다음과 같은 제약사항이 있다.
* 프로그래머는 누구나 실수할 수 있다.
* 컴파일러가 잡아낼 수 없는 교묘한 에러도 있다. 특히 상속과 관련된 유효범위 에러가 그렇다.
* 구현 기법의 하나로 상속을 사용하면 테스트 작업이 단순해진다는 것이 기존의 보편적 이론이었다. 그러나 페리와 카이저를 비롯한 다른 팀원은 사실상 클래스 인스턴스로 요청되던 작업들이 하위클래스 인스턴스로 요청되는 각각의 경우마다 수많은 테스트를 작성해야 함을 입증해 보였다. 테스트 설계자가 전지전능하거나 섬세하게 신경 쓰지 않는 이상, 테스트 스위트가 감당할 수 없는 각종 경우가 있을 수도 있다. 프로그램의 있을 수 있는 모든 실행 경로를 테스트한다는 건 컴퓨터 연산으론 불가능하다. 따라서 테스트 스위트로 모든 경우를 잡아냈다고 장담할 순 없다.
* 코드 검수자도 프로그래머와 마찬가지로 실수할 수 있다. 게다가 검수자는 본업에도 바쁜 와중에 남이 작성한 코드를 완벽히 검수하지 못할 수도 있다.

리팩토링 도구를 정의하고 시제품화한 후, 그것으로 리팩토링을 프로그램에 안전하게 적용할 수 있는지 검사해서 가능하다고 판단되면 그 프로그램을 리팩토링하는 방법도 있다. 이렇게 하면 사람의 실수로 생길 수 있는 버그는 대부분 예방된다.

리팩토링 도구로 모든 안전성 검사가 가능하다. 프로그램을 리팩토링해야 하는 개발자는 리팩토링 도구에게 코드를 검사하라고 시키고 안전하다는 결과가 표시되면 해당 리팩토링을 적용하기만 하면 된다. 

다양한 수준의 안전성을 리팩토링에 적용할 수 이싿. 일부는 적용하기 쉬운 대신 고급 수준의 안전성은 보증할 수 없다. 리팩토링 도구를 사용하면 많은 장점을 얻을 수 있다. 리팩토링 도구는 지루한 단순 검사를 대신해주며, 만일 검사하지 않고 넘어갔다면 리팩토링 결과 프로그램이 고장났을 문제점들을 미리 표시한다.

컴파일, 테스트, 코드 감수 과정에서 찾아낼 온갖 에러는 리팩토링 도구에도 표시되지만 컴파일, 테스트, 코드 감수를 실시하는 건 여전히 중요하다. 실시간 시스템을 개발하거나 개선할 땐 더욱 그렇다. 프로그램은 단독적으로 실행되는 경우가 드물고 서로 통신 시스템의 네트워크를 구성하고 있을 때가 많다. 일부 리팩토링은 코드를 깔끔하게 정리함과 동시에 프로그램 실행속도를 높여준다. 한 프로그램의 속도를 높이면 다른 프로그램은 병목 현상으로 인해 성능이 떨어질 수도 있다. 이 현상은 마이크로프로세서를 업그레이드해서 시스템 일부분의 속도를 높이는 경우와 비슷하며, 비슷한 방법으로 전체 시스템 성능을 약간 조정하고 테스트해야 한다. 이와 정반대로 일부 리팩토링은 전체 성능을 약간 떨어뜨릴 수 있지만 웬만해선 성능이 그런식으로 떨어지는 일은 드물다.

안전성을 꾀하는 각종 방법의 목적은 리팩토링으로 인해 프로그램에 에러가 새로 생기는 걸 방지하는 것이다. 이런 방법은 리팩토링하기 전부터 프로그램에 있던 버그를 감지하거나 수정하진 않는다. 하지만 리팩토링하고 나면 그런 버그도 쉽게 찾아 수정할 수 있다.
<hr/>

### 현실성 다시 검토하기
개발자가 주로 표출하는 네 가지 고민
* 난 리팩토링을 어떻게 하면 되는지 모르겠다.
* 긍정적 효과가 장기적이라면 지금 내가 공들일 필요가 있나? 오랜 시간이 흘렀을 때 난 이미 프로젝트를 그만 뒀을 수도 있고, 그럼 어차피 리팩토링으로 인한 수확은 다른 사람이 차지할 텐데 말이다.
* 고용주는 새 기능을 제작하라고 개발자에게 월급을 주는데, 리팩토링 코드는 불필요한 번외 업무다.
* 리팩토링하다가 괜히 잘 돌아가던 프로그램이 고장날지도 모른다.

방향 제시
* 리팩토링할 코드가 여러 팀원이 담당하는 코드에 흩어져 있을 땐 어떻게 할까? 관례에 따른 수정 관리 방식을 사용하는 게 적절할 때도 있다. 그렇지 않을 땐 프로그램이 체계적으로 설계되고 리팩토링됐다는 전제 하에 하위 시스템은 여러 리팩토링 기법을 적용해도 코드의 극히 일부만 영향을 받게끔 잘 분리될 것이다.
* 코드에서 파생된 여러 코드 버전이나 행이 있을 땐 어떻게 할까? 경우에 따라 리팩토링이 모든 버전에 적절할 수도 있는데, 이럴 땐 리팩토링을 적용하기 전에 안전성만 검사하면 된다. 그렇지 않을 땐 리팩토링은 코드 검사 및 리팩토링 과정을 단순화하는 일부 버전의 코드에만 적용해야 한다. 여러 버전에 발생할 수정을 관리하려면 주로 전통적인 버전 관리 기법 대부분을 적용해야 한다. 리팩토링을 적용하면 다양한 버전을 합쳐서 업데이트 코드로 만들기가 쉬워지고 이로써 버전 관리가 간편해질 수도 있다.
<hr/>

### 소프트웨어 재사용과 기술 변경이 미치는 영향
프로그램 재사용에 대한 실무적 고민은 리팩토링에 대한 고민과 비슷하다.
* 기술 부서 직원이 재사용할 코드가 무엇인지 모르거나 재사용하는 방법을 모를 수도 있다.
* 기술 부서 직원이 단기적 효과를 얻을 수 없다면 재사용 방법을 적용할 동기가 생기지 않을 수도 있다.
* 초과 비용, 학습 속도, 발견 비용 문제가 해결되지 않으면 재사용 방법을 선택하지 않을 것이다.
* 재사용 방법의 채택으로 인해 프로젝트에 지장이 생겨선 안 된다. 구 버전의 제약사항을 갖는 기존 코드나 구현부를 이용해야 한다는 강박관념에 시달릴 수도 있다. 새 구현 코드는 기존 시스템과 상호작용하거나 호환되어야 한다.
