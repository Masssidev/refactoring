# 메서드 호출 단순화
객체에서 가장 중요한 것은 인터페이스다. 이해와 사용이 쉬운 인터페이스를 작성하는 기술이야 말로 좋은 객체지향 소프트웨어 개발에 꼭 필요하다.
<hr/>

### 메서드명 변경
*메서드명을 봐도 기능을 알 수 없을 땐 메서드명을 직관적인 이름으로 바꾼다.*
##### 동기
메서드명만 봐도 그 메서드의 의도를 한눈에 알 수 있어야 한다. 메서드 기능을 설명하기 위해 넣는 주석을 떠올린 후 그 주석을 메서드명으로 바꾸면 이러한 메서드명을 쉽게 정할 수 있다.

메서드의 이름이 적절치 않다면 반드시 변경해야 한다. 코드는 컴퓨터보다 인간이 알아보기 쉽게 작성해야 한다. 인간이 알아보기 쉬우려면 코드에 사용된 모든 이름이 적절해야 한다. 
##### 방법
* 메서드 시그너처가 상위클래스나 하위클래스에 구현되어 있는지 검사한다. 만약 구현되어 있다면 각 구현부를 대상으로 다음 단계들을 실시한다.
* 새 이름으로 새 메서드를 선언한다. 코드의 원래 내용을 새 메서드로 복사하고 적절히 수정한다.
* 컴파일한다.
* 새 메서드를 호출하게 원본 메서드의 내용을 수정한다.
  * 참조하는 부분이 적다면 이 단계는 건너뛰어도 된다.
* 컴파일과 테스트를 실시한다.
* 원본 메서드 참조 부분을 전부 찾아서 새 메서드를 참조하게 수정한다. 수정할 때마다 테스트를 실시한다.
* 원본 메서드를 삭제한다.
  * 원본 메서드가 인터페이스에 들어 있어서 삭제할 수 없다면 그 메서드를 그대로 두고 deprecated로 표시한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 매개변수 추가
*메서드가 자신을 호출한 부분의 정보를 더 많이 알아야 할 땐 객체에 그 정보를 전달할 수 있는 매개변수를 추가한다.*
##### 동기
매개변수 추가는 흔히 사용되는 리팩토링 기법이라서 웬만한 사람은 사용해본 적이 있을 것이다. 메서드를 수정해야 하는데 이 과정에서 기존에 전달하지 않은 정보가 필요할 땐 이 정보를 전달하고자 매개변수를 추가해야 한다.

매개변수를 추가하는 대신 다른 방법을 사용할 수 있을 때도 많은데, 그럴 땐 가능하면 그런 대안을 사용하는게 낫다. 매개변수를 추가하면 매개변수 세트가 더 길어지기 때문이다. 매개변수 나열이 길수록 기억하기도 힘들고 데이터 뭉치라는 구린내가 날 가능성이 높아서 좋지 않다.
##### 방법
* 메서드 시그너처가 상위클래스나 하위클래스에 구현되어 있는지 검사한다. 구현되어 있다면 이 과정을 모든 구현부마다 실시한다.
* 추가한 매개변수를 전달받는 새 메서드를 선언한다. 원본 메서드의 내용을 새 메서드로 복사한다.
  * 매개변수를 둘 이상 추가해야 할 때는 한꺼번에 추가하는 것이 더 간편하다.
* 컴파일한다.
* 새 메서드를 호출하게 원본 메서드의 내용을 수정한다.
  * 참조하는 부분이 별로 없다면 이 단계를 건너뛰어도 된다.
  * 새 매개변수에 어떤 값이든 전달해도 되지만, 보통 객체 매개변수엔 null을 전달하고 내장 타입엔 명백히 이상한 값을 전달해서 참조하는 부분을 찾아낸다. 이런 경우를 쉽게 찾으려면 숫자응 0이 아닌 값을 전달하는 것이 좋다.
* 컴파일과 테스트를 실시한다.
* 원본 메서드 참조 부분을 전부 찾아서 새 메서드 참조로 바꾼다. 수정할 때마다 테스트를 실시한다.
* 원본 메서드를 삭제한다.
  * 원본 메서드가 인터페이스에 들어 있고 그 메서드의 모든 호출 부분에 접근할 수 없다면 원본 메서드는 그대로 놔두고 deprecated로 표시한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 매개변수 제거
*메서드가 어떤 매개변수를 더 이상 사용하지 않을 땐 그 매개변수를 삭제한다.*
##### 동기
매개변수는 필요한 정보를 나타낸다. 매개변수로 다른 값이 전달되면 결과가 달라진다. 호출 부분에서는 무슨 값을 전달할지 신중해야 한다. 매개변수를 제거하지 않으면 그 메서드를 사용하는 모든 곳이 불필요한 추가 작업을 수행하게 된다.

이때 재정의 메서드에 주의해야 한다. 그 메서드의 다른 재정의 메서드에서 매개변수가 사용되진 않는지 살펴봐야 한다. 그런 상황에 사용 가능한 별도의 메서드를 추가로 작성할 수도 있지만, 호출 부분에서 그 메서드가 어떤 식으로 사용되는지 검사해서 그렇게 할 가치가 있는지부터 판단해야 한다.

만약 재정의 메서드가 특정 하위클래스를 처리하고 매개변수를 찾는 부가 작업을 수행한다는 사실이나 null이 되지 않게 할 수 있음을 클래스 계층 정보를 통해 알고 있다는 사실을 일부 호출 코드가 이미 알고 있다면, 매개변수 없는 메서드를 하나 추가한다. 호출 코드가 어느 클래스에 어느 메서드가 있는지 알 필요 없다면 호출 코드를 그대로 둬야 한다. 
##### 방법
* 메서드 시그너처가 상위클래스나 하위클래스에 구현되어 있는지 검사한다. 하위클래스나 상위클래스가 제거하려는 매개변수를 사용하는지 검사해서 사용한다면 이 리팩토링은 하지 말아야 한다.
* 제거할 매개변수가 없는 새 메서드를 선언한다. 원본 메서드의 내용을 새 메서드로 복사한다.
  * 매개변수를 둘 이상 제거해야 할 때는 한꺼번에 제거하는 것이 편리하다.
* 컴파일한다.
* 새 메서드를 호출하도록 원본 메서드의 내용을 수정한다.
  * 참조 부분이 별로 없다면 이 단계를 건너뛰어도 된다.
* 컴파일과 테스트를 실시한다.
* 원본 메서드 참조 부분을 전부 찾아서 새 메서드 참조로 수정한다. 수정할 때마다 테스트를 실시한다.
* 원본 메서드를 삭제한다.
  * 원본 메서드가 인터페이스에 들어 있고 그 메서드의 어느 호출 부분에도 접근할 수 없다면, 원본 메서드를 그대로 두고 deprecated로 표시한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 상태 변경 메서드와 값 반환 메서드를 분리
*값 반환 기능과 객체 상태 변경 기능이 한 메서드에 들어 있을 땐 질의 메서드와 변경 메서드로 분리한다.*
##### 동기
값을 반환하며 눈에 띄는 부작용이 없는 함수를 작성했다면 그 함수는 높은 가치가 있다. 그런 함수는 필요할 때마다 몇 번이든 호출할 수 있으며, 그런 함수를 호출하는 코드는 메서드 안의 다른 위치로 옮길 수 있다. 간단히 말해 그런 함수를 사용하면 개발자가 신경 쓸 일이 훨씬 줄어든다.

부작용 있는 메서드와 부작용 없는 메서드의 차이를 명확히 분간하는 것이 좋다. 값을 반환하는 모든 메서드는 눈에 띄는 부작용이 없어야 한다는 규칙을 따르는 것이 좋다.

값을 반환한느 메서드가 있는데 그 메서드에 부작용이 있다면 상태 변경 부분과 값 반환 부분을 별도의 메서드로 각각 분리해야 한다.
##### 방법
* 원본 메서드와 같은 값을 반환하는 값 반환 메서드를 작성한다.
  * 원본 메서드를 관찰하여 무엇을 반환하는지 알아낸다. 반환된 값이 임시적이면 임시 할당 위치를 살펴본다.
* 메서드 호출의 결과를 반환하게 원본 메서드를 수정한다.
  * 원본 메서드 안의 모든 return 문은 다른 것을 반환하게 작성하지 말고 return newQuery() 라고 작성해야 한다.
  * 원본 메서드가 반환 값을 임시변수에 한 번 할당한다면, 그 임시변수를 제거할 수 있어야 한다.
* 컴파일과 테스트를 실시한다.
* 각 호출에 대해 한 번의 원본 메서드 호출을 값 반환 메서드 호출로 수정한다. 값 반환 메서드 호출행 앞에 원본 메서드 호출을 추가한다. 호출 메서드를 하나 수정할 때마다 테스트한다.
* 원본 메서드를 void 타입으로 수정하고 안의 return 문을 삭제한다.
###### 병행처리 문제
멀티스레딩 시스템에서는 테스트와 설정 연산 수행을 한 번에 실시하는 것이 중요하다. 값 반환 메서드와 상태 변경 메서드를 반드시 분리해야 한다는 점엔 변함이 없다. 다만 두 기능을 모두 수행하는 제 3의 메서드를 두어야 한다. 질의 겸 상태 변경 메서드는 질의 메서드와 상태 변경 메서드를 호출하고 동기화한다. 질의 메서드와 상태 변경 메서드가 동기화되지 않을 경우, 두 메서드의 개방도를 패키지 수준이나 private 수준으로 제한해야 한다. 그렇게 하면 두 개의 이해하기 쉬운 메서드로 분리된 기능이 안전하면서도 동기화된 상태가 된다. 이로써 이 두 개의 저수준 메서드는 다른 용도로도 사용 가능하다.
<hr/>

### 메서드를 매개변수로 전환
*여러 메서드가 기능은 비슷하고 안에 든 값만 다를 땐 서로 다른 값을 하나의 매개변수로 전달받는 메서드를 하나 작성한다.*
##### 동기
기능은 비슷하지만 몇 가지 값에 따라 결과가 달라지는 메서드가 여러 개 있을 때 각 메서드를 전달된 매개변수에 따라 다른 작업을 처리하는 하나의 메서드로 만들면 편리하다. 그렇게 수정하면 중복 코드가 없어지고 매개변수 추가를 통해 다양한 것을 처리할 수 있어서 유연성도 커진다.
##### 방법
* 여러 메서드를 대체할 수 있는 매개변수 메서드를 작성한다.
* 컴파일한다.
* 새 메서드를 호출하도록 원본 메서드 하나를 수정한다.
* 컴파일과 테스트를 실시한다.
* 모든 메서드를 대상으로 앞의 절차를 반복 실시하면서 테스트한다.

앞의 절차를 메서드 전반에 적용할 순 없고 메서드의 일부분에만 적용 가능할 때도 있다. 그럴 땐 우선 그 부분을 별도의 메서드로 빼낸 후 그 메서드에 매개변수를 추가한다.
<hr/>

### 매개변수를 메서드로 전환
*매개변수로 전달된 값에 따라 메서드가 다른 코드를 실행할 땐 그 매개변수로 전달될 수 있는 모든 값에 대응하는 메서드를 각각 작성한다.*
```
void setValue (String name, int value) {
  if (name.equals("height")) {
    _height = value;
    return;
  }
  if (name.equals("width")) {
    _width = value;
    return;
  } Assert.shouldNeverReachHere();
}
```
```
void setHeight(int arg) {
  _height = arg;
}
void setWidth (int arg) {
  _width = arg;
}
```
##### 동기
매개변수를 메서드로 전환은 메서드를 매개변수로 전환의 작업 절차를 거꾸로 하면 된다. 이 리팩토링 기법은 일반적으로 한 매개변수의 값이 여러 개가 될 수 있을 때 조건문 안에서 각 값을 검사하여 다른 기능을 수행하는 메서드에 적용하게 된다. 호출하는 부분은 매개변수에 값을 지정하여 무엇을 수행할지 판단해야 하므로, 여러 메서드를 작성하고 조건문은 없애는 것이 좋다. 그러면 조건에 따른 실행도 방지하면서 컴파일할 때 검사가 된다는 장점이 있다. 더군다나 인터페이스도 더 명료해진다. 그 메서드를 사용하는 프로그래머는 클래스에서 그 메서드가 사용된 부분을 관찰하고 유효한 매개변수 값도 알아내야 한다. 유효한 매개변수 값을 알아내는 방법을 제대로 설명한 문서는 거의 없다.

컴파일할 때의 검사는 불필요할 때도 있겠지만 인터페이스의 명료성은 언제나 큰 장점이다. Switch.beOn() 메서드가 Switch.setState(true) 메서드에 비해 훨씬 이해하기 쉬운데다가 메서드 안의 부울값(boolean) 필드를 설정하기만 하면 되기 때문이다.

매개변수 값이 많이 변할 가능성이 있을 때는 매개변수를 개별 메서드로 전환을 실시하면 안 된다. 이럴 때 필드를 그냥 전달받은 매개변수로 지정하려면 간단한 속성 쓰기 메서드를 사용하면 된다. 조건에 따라 다른 동작을 실행하게 해야 할 때는 조건문을 재정의로 전환을 실시해야 한다.
##### 방법
* 매개변수의 각 값에 해당하는 개별 메서드를 작성한다.
* 조건문의 각 절마다 해당되는 새 메서드 호출을 넣는다.
* 각 절을 수정할 때마다 테스트를 실시한다.
* 조건문이 든 원본 메서드의 각 호출 부분을 알맞은 새 메서드 호출로 바꾼다.
* 컴파일과 테스트를 실시한다.
* 호출 부분을 전부 고쳤으면 조건문이 든 매개변수 메서드를 삭제한다.
<hr/>

### 객체를 통째로 전달
*객체에서 가져온 여러 값을 메서드 호출에서 매개변수로 전달할 땐 그 객체를 통째로 전달하게 수정한다.*
```
int low = daysTempRange().getLow();
int high = daysTempRange().getHigh();
withinPlan = plan.withinRange(low, high);
```
```
withinPlan = plan.withinRange(daysTempRange());
```
##### 동기
객체가 한 객체에 든 여러 값을 메서드 호출할 때 매개변수로 전달하고 있다면 이 리팩토링 기법을 적용해야 한다. 이럴 땐 호출된 객체가 나중에 새 데이터 값을 필요로 할 때마다 이 메서드를 호출하는 모든 부분을 찾아서 수정해야 한다는 문제가 있다. 데이터를 넘겨주는 객체 자체를 통째로 넘기면 이 문제를 방지할 수 있다. 이렇게 하면 호출된 객체는 넘겨주는 객체로부터 필요한 것을 무엇이든 요청할 수 있다.

객체를 통째로 전달을 실시하면 매개변수 세트 변경의 편의성뿐 아니라 코드를 알아보기도 쉬워진다. 매개변수 나열이 길면 호출하는 부분과 호출되는 부분에서 어느 값들이 거기 있었는지를 전부 기억해야 하므로 작업이 힘들어질 수 있다. 게다가 호출되는 객체가 데이터를 넘겨주는 객체를 통째로 넘겼더라면 사용할 수 있었을 다른 메서드를 이용할 수 없으므로 중복 코드가 생긴다.

객체를 통째로 전달하는 방식에도 단점은 있다. 값을 전달할 때 호출되는 객체가 그 값들에 의존하게 되지만 값이 추출된 객체에는 의존하지 않게 된다는 점이다. 통 객체를 전달하면 통 객체와 호출된 객체가 서로 의존하게 된다. 이것이 의존성 구조를 망가뜨릴 것 같으면 객체를 통째로 전달을 실시하지 말아야 한다.

호출하는 객체가 통 객체에서 가져올 값이 하나뿐이라면 통 객체를 전달하는 것보다 그 값 하나만 전달하는 것이 효율적이라서 객체를 통째로 전달을 실시하지 말아야 한다는 얘기가 있는데 적어도 코드의 명료성 측면에선 값 하나를 넘기나 객체 하나를 넘기나 마찬가지다. 다만, 매개변수로 값을 전달하면 성능이 떨어질 수 있다. 이 리팩토링 기법의 문제는 종속성이 생긴다는 점이다.

호출된 메서드가 다른 객체에 있는 많은 값을 사용한다면, 호출된 메서드는 사실상 그 값들을 넘겨주는 객체에 정의해야 한다. 객체를 통째로 전달의 실시 여부를 고민 중이라면 대안으로 메서드 이동을 고려해본다.

통째로 전달할 객체를 아직 정의하지 않았을 땐, 매개변수 세트를 객체로 전환을 실시해야 한다.

호출하는 객체가 자체의 데이터 값 여러 개를 매개변수로 전달하는 코드를 흔히 보게 된다. 이럴 땐 적절한 속성 접근 데이터가 있고 의존성에 대한 걱정이 없다면, 호출하면서 여러 개의 데이터 값 대신 this를 전달하면 된다.
##### 방법
* 데이터가 속한 통째로 전달할 객체에 새 매개변수를 작성한다.
* 컴파일과 테스트를 실시한다.
* 통째로 전달할 객체에서 가져와야 할 매개변수를 파악한다.
* 한 매개변수를 선택해서 메서드 안에서 그 매개변수를 참조하는 부분을 넘겨받은 통째로 전달할 객체 안의 적절한 메서드 호출로 바꾼다.
* 그 매개변수를 삭제한다.
* 컴파일과 테스트를 실시한다.
* 통째로 전달할 객체에서 가져올 수 있는 모든 매개변수를 대상으로 위의 과정을 반복한다.
* 삭제한 매개변수들을 가져오는 호출 메서드 안의 코드를 삭제한다.
  * 당연한 얘기지만, 이 매개변수들이 코드의 다른 곳에 전혀 사용되지 않을 때만 수행한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 매개변수 세트를 메서드로 전환
*객체가 A 메서드를 호출해서 그 결과를 B 메서드에 매개변수로 전달하는데, 결과를 매개변수로 받는 B 메서드도 직접 A 메서드를 호출할 수 있을 땐 매개변수를 없애고 A 메서드를 B 메서드가 호출하게 한다.*
```
int basePrice = _quantity * _itemPrice;
discountLevel = getDiscountLevel();
double finalPrice = discountedPrice (basePrice, discountLevel);
```
```
int basePrice = _quantity * _itemPrice;
double finalPrice = discountedPrice (basePrice);
```
##### 동기
메서드가 매개변수로 전달받는 값을 다른 방법으로도 가져올 수 있다면, 그 방법을 택해야 한다. 매개변수 나열이 길면 코드가 복잡해지므로 가능하면 매개변수를 줄여야 한다.

전달할 매개변수를 줄이려면 같은 계산을 수신 메서드도 할 수 있는지 검사해야 한다. 객체가 자신의 메서드를 호출하지만 호출한 메서드의 매개변수가 계산에 전혀 사용되지 않는다면, 그 계산을 별도의 메서드로 만들고 매개변수를 삭제할 수 있다. 호출하는 객체를 참조하는 다른 객체에 있는 메서드를 호출할 때도 마찬가지다.

호출한 메서드의 매개변수가 계산에 사용될 땐 매개변수를 삭제하면 안 된다. 왜냐하면 그 매개변수는 호출이 일어날 때마다 변할 수 있기 때문이다. 이건 그 매개변수가 메서드로 교체할 수 없을 때만 해당된다. 결과 수신 메서드에 결과 송신 메서드 호출 코드가 들어 있지 않고 호출 코드를 전혀 추가할 생각이 없더라도 매개변수를 삭제하면 안 된다.

나중에 메서드를 매개변수 메서드로 바꿀 가능성에 대비해 매개변수를 두는 경우가 가끔 있다. 그럴 때도 매개변수는 없애는 것이 좋다. 매개변수를 메서드로 바꾸는 작업은 필요할 때만 한다. 심지어 필요할 때조차 매개변수는 있어서 좋을 게 없다는 걸 깨달을 것이다. 인터페이스 수정으로 인해 프로그램 여기저기에 삽입된 코드 중 상당 부분을 수정해야 하는 등의 끔찍한 결과에 처하게 될 때만 예외적으로 매개변수를 사용하게 내버려두는 것이 좋다. 수정 결과를 그토록 끔찍하게 만드는 종속성을 줄일 수 있는지 여부도 조사해야 한다. 인터페이스가 안정적인 건 좋지만, 그렇다고 해서 문제 있는 인터페이스를 방치하는 건 문제다.
##### 방법
* 필요하다면 매개변수를 사용한 계산 부분을 별도의 메서드로 빼낸다.
* 메서드 안의 매개변수 사용 부분을 추출한 메서드 호출로 수정한다.
* 하나씩 수정할 때마다 컴파일과 테스트를 실시한다.
* 매개변수를 대상으로 매개변수 제거를 실시한다.
<hr/>

### 매개변수 세트를 객체로 전환
*여러 개의 매개변수가 항상 붙어 다닐 땐 그 매개변수들을 객체로 바꾼다.*
##### 동기
특정 매개변수들이 늘 함께 전달되는 경우들이 있다. 여러 메서드가 한 클래스나 여러 클래스에서 이 매개변수 집합을 사용할 가능성이 있다. 이런 클래스들은 데이터 뭉치이므로 그 모든 데이트가 든 객체로 바꿀 수 있다. 데이터를 그룹으로 묶으려면 이 매개변수들을 객체로 바꾸는 것이 좋다. 이 리팩토링 기법을 실시하면 매개변수 세트가 짧게 줄어서 좋다. 새 객체에 정의된 속성 접근 메서드로 인해 코드의 일관성도 개선되고, 결과적으로 코드를 알아보거나 수정하기도 쉬워진다.

더불어 매개변수를 한 덩이로 만들면 기능을 새 클래스로 옮길 수 있어서 훨씬 좋다. 메서드 안에 매개변수 값에 대한 공통적인 조작을 넣는 경우가 많다. 이 동작을 새 객체로 옮기면 상당량의 중복 코드를 없앨 수 있다.
##### 방법
* 대체할 매개변수 그룹에 해당하는 새 클래스를 작성하고, 그 클래스를 변경불가로 만든다.
* 컴파일한다.
* 새 데이터 뭉치에 매개변수 추가를 적용한다. 새 매개변수에 기본 값을 사용한다.
  * 호출 부분이 많으면 기존 시그너처를 그대로 두고 새 메서드를 호출하게 한다. 그 리팩토링을 기존 메서드에 먼저 적용한다. 그런 다음 호출 부분들을 하나씩 옮긴 후 기존 메서드는 삭제하면 된다.
* 데이터 뭉치 안의 각 매개변수마다 시그너처에서 해당 매개변수를 삭제한다. 그 값 대신 매개변수 객체를 사용하게 호출 부분과 메서드 내용을 수정한다.
* 매개변수를 옮길 때마다 컴파일과 테스트를 실시한다.
* 매개변수 삭제를 전부 완료했으면, 메서드 이동을 적용하여 매개변수 객체로 옮길 수 있는 기능을 찾는다.
  * 매개변수 객체로 옮길 수 있는 기능은 메서드 전체일 수도 있고 일부분일 수도 있다. 메서드의 일부분일 경우에는 우선 메서드 추출을 실시한 후 새로 빼낸 메서드로 옮기면 된다.
###### 범위 패턴
* 범위를 처리하는 단순 데이터 클래스를 선언한다.
* 클래스를 변경불가로 만든다. 즉, 모든 값을 final로 선언하고 생성자 안에 지정하여 값을 변경하는 메서드가 없게 만든다.
> 이 방법을 사용하면 각종 별칭 버그가 방지되어 좋다. 
<hr/>

### 쓰기 메서드 제거
*생성할 때 지정한 필드 값이 절대로 변경되지 말아야 할 땐 그 필드를 설정하는 모든 쓰기 메서드를 삭제한다.*
##### 동기
쓰기 메서드가 있다는 건 필드 값을 변경할 수 있다는 얘기다. 객체가 생성된 후에는 필드가 변경되지 말아야 한다면, 쓰기 메서드를 작성하지 않아야 한다. 그렇게 하면 확실히 의도가 달성되고 필드가 수정될 가능성을 차단할 수 있다.

이 리팩토링 기법은 프로그래머가 간접적인 변수 접근을 맹목적으로 이용할 때 실시해야 한다.
##### 방법
* 쓰기 메서드가 생성할 때나 생성자가 호출하는 메서드에서만 호출되는지 검사한다.
* 컴파일과 테스트를 실시한다.
* 쓰기 메서드가 생성자 안이나 생성자가 호출한 메서드 안에서만 호출되는지 검사한다.
* 변수에 직접 접근할 수 있게 생성자를 수정한다.
  * 상위클래스의 private 필드를 설정하는 하위클래스가 있으면 생성자를 변수에 직접 접근하게 수정할 수 없다. 이럴 땐 상위클래스에 private 필드 값을 설정하는 protected 메서드(실제론 생성자)를 넣어야 한다. 상위클래스 메서드명은 쓰기 메서드와 혼동되지 않는 이름으로 정한다.
* 컴파일과 테스트를 실시한다.
* 쓰기 메서드를 삭제한다.
* 컴파일한다.
##### 예제
* 수정이 간단할 때는 생성자를 수정해도 되지만, 수정이 복잡하거나 별도의 메서드에서 호출해야 할 때는 따로 메서드를 작성해야 한다. 이때 메서드 이름은 의도가 확실히 드러나게 정해야 한다.
<hr/>

### 메서드 은폐
*메서드가 다른 클래스에 사용되지 않을 땐 그 메서드의 반환 타입을 private로 만든다.*
##### 동기
리팩토링하다 보면 처음에 정한 메서드의 개방도를 바꿀 일이 많이 생긴다. 메서드를 어떨 때 한층 공개적으로 만들어야 할지 판단하는 방법은 간단하다. 다른 클래스가 그 메서드를 사용한다면 개방도를 높여야 한다. 하지만 메서드의 개방도를 어떨 때 낮춰야 할지를 판단하기는 비교적 어렵다. 자동으로 모든 메서드를 검사해서 그것들을 비공개로 해도 될지 검사해줄 도구가 있다면 더할 나위 없겠지만, 그런 도구가 없다면 개발자가 정기적으로 이 검사를 손수 해야 한다.

특히 흔한 상황은 더 많은 기능이 든 리치 인터페이스를 작성할 때 메서드를 감추고, 읽고 쓰는 것이다. 이 상황은 캡슐화된 데이터 보관 객체와 비슷한 클래스를 먼저 작성할 때 가장 흔히 볼 수 있다. 클래스 안에 넣은 기능이 많을수록 읽기/쓰기 메서드의 대부분은 더 이상 public으로 놔둘 이유가 없다. 이럴 땐 그 메서드들을 비공개로 만들어도 된다. 읽기 메서드나 쓰기 메서드를 private 타입으로 고치고 변수에 직접 접근하게 수정하면 그 메서드를 삭제할 수 있다.
##### 방법
* 메서드의 개방도를 낮출 여지가 있는지 정기적으로 검사한다.
  * lint 스타일의 도구를 사용하고 가끔 수동 검사도 실시한다. 그리고 다른 클래스에 들어 있는 메서드 호출을 삭제할 시점을 검사한다.
  * 특히 쓰기 메서드에서 이러한 경우를 찾는다.
* 각 메서드를 가능하면 private 타입으로 만든다.
* private 타입으로 만들 때마다 테스트를 실시한다.
  * 이 검사는 컴파일러가 자동으로 수행하므로 수정할 때마다 컴파일할 필요는 없다. 그리고 한 곳이 잘못되어도 찾기 쉽다.
<hr/>

### 생성자를 팩토리 메서드로 전환
*객체를 생성할 때 단순한 생성만 수행하게 해야 할 땐 생성자를 팩토리 메서드로 교체한다.*
```
Employee (int type) {
  _type = type;
}
```
```
static Employee create(int type) {
  return new Employee(type);
}
```
##### 동기
생성자를 팩토리 메서드로 전환을 실시해야 할 가장 확실한 상황은 분류 부호를 하위클래스로 바꿀 때 발생한다. 분류 부호를 사용해 작성한 객체가 있는데 현 시점에서 하위클래스가 필요해졌다. 어느 하위클래스를 사용할지는 분류 부호에 따라 달라진다. 하지만 생성자는 요청된 객체의 인스턴스 반환만 할 수 이싿. 따라서 생성자를 팩토리 메서드로 바꿔야 한다.

생성자가 너무 제한되는 다른 상황에서도 팩토리 메서드를 사용할 수 있다. 팩토리 메서드는 값을 참조로 전환을 실시하기 위해 꼭 필요하다. 팩토리 메서드는 매개변수의 숫자와 타입을 벗어나는 다른 생성 동작을 나타낼 때도 사용할 수 있다.
##### 방법
* 팩토리 메서드를 작성한다. 그 메서드의 내용을 기존의 생성자 호출로 수정한다.
* 모든 생성자 호출을 팩토리 메서드 호출로 바꾼다.
* 하나씩 바꿀 때마다 컴파일과 테스트를 실시한다.
* 생성자를 private로 선언한다.
* 컴파일한다.
<hr/>

### 하향 타입 변환을 캡슐화
*메서드가 반환하는 객체를 호출 부분에서 하향 타입 변환해야 할 땐 하향 타입 변환 기능을 메서드 안으로 옮긴다.*
```
Object lastReading() {
  return reading.lastElement();
}
```
```
Reading lastReading() {
  return (Reading) readings.lastElement();
}
```
##### 동기
하향 타입 변환은 타입을 철저히 따지는 객체지향 언어에서 제일 귀찮은 일이다. 왜냐하면 하향 타입 변환은 불필요하단 느낌이 드는데다, 컴파일러가 스스로 파악해야 마땅할 것 같은 정보를 개발자가 일일이 알려줘야 하기 때문이다. 하지만 타입을 알아내기 까다로울 때가 많기에 웬만해선 개발자가 직접 작성해야 한다. 템플릿이 없는 자바에선 컬렉션에서 객체를 꺼낼 때마다 하향 타입 변환을 해야 하는 게 보통이다.

하향 타입 변환은 필요악일 수도 있지만, 웬만하면 사용하지 말아야 한다. 만약 메서드에서 값을 반환하는데, 반환 값의 타입이 메서드 시그너처의 타입보다 더 구체적이라면 클라이언트에 불필요한 작업을 둔 것이다. 클라이언트가 하향 타입 변환을 하게 하지 말고, 가능하면 항상 가장 구체적인 타입을 작성해야 한다. 

이런 상황은 이터레이너타 컬렉션을 반환하는 메서드에서 흔히 발견된다. 
##### 방법
* 메서드 호출의 결과로 반환된 값을 하향 타입 변환해야 하는 각종 상황을 찾는다.
  * 이런 상황은 컬렉션이나 이터레이터를 반환하는 메서드에서 자주 볼 수 있다.
* 하향 타입 변환 코드를 그 메서드 안으로 옮긴다.
  * 컬렉션을 반환하는 메서드에 컬렉션 캡슐화를 적용한다.
##### 예제
* 메서드가 하위클래스를 반환하게 수정하면 메서드 시그너처가 변하지만, 컴파일러는 상위클래스 대신 하위클래스를 사용할 수 있음을 알고 있기에 기존 코드에 문제가 생기진 않는다. 당연한 얘기지만, 하위클래스엔 상위클래스의 규칙을 깨는 기능을 넣어선 안 된다.
<hr/>

### 에러 부호를 예외 통지로 교체
*메서드가 에러를 나타내는 특수한 부호를 반환할 땐 그 부호 반환 코드를 예외 통지 코드로 바꾼다.*
```
int withdraw(int amount) {
  if (amount > _balance)
    return -1;
  else {
    _balance -= amount;
    return 0;
  }
}
```
```
void withdraw(int amount) throws BalanceException {
  if (amount > _balance) throw new BalanceException();
  _balance -= amount;
}
```
##### 동기
현실에서처럼 컴퓨터에서도 일이 잘못될 때가 있기 마련이다. 뭔가가 잘못되었을 때 개발자는 그 오류에 대응하는 작업을 실시해야 한다. 

문제는 프로그램에서 에러를 찾는 코드 부분에 반드시 그 에러를 처리하는 기능이 들어 있는 것은 아니란 점이다. 에러 찾기 루틴은 에러를 발견하면 자신을 호출한 부분에 그것을 알리며, 호출 부분이 그 에러를 상위 호출 코드로 보낼 수도 있다. 대부분의 언어에서 특수한 출력은 에러를 표시하는 데 사용된다. 

자바에는 예외라는 좋은 수단이 있다. 예외는 에러 처리를 일반적인 처리와 확실히 분리시키기 때문에 좋다. 이로써 프로그램을 이해하기 쉬워지는데, 코드를 이해하기 쉽게 만드는 것은 중요하다.
##### 방법
* 확인된 예외와 미확인 예외 중 어느 것을 사용해야 할지 판단한다.
  * 호출 전에 호출하는 부분이 조건을 검사해야 한다면 미확인 예외로 한다.
  * 예외가 확인된 것이면 새 예외를 작성하거나 기존 예외를 사용한다.
* 호출 부분을 전부 찾아서 그 예외를 사용하게 수정한다.
  * 미확인 예외일 땐 호출 부분이 메서드 호출 전에 적절한 검사를 하게 한다. 하나씩 수정할 때마다 컴파일과 테스트를 실시한다.
  * 확인된 예외일 땐 호출 부분이 try 절 안에서 메서드를 호출하게 한다.
* 메서드 시그너처를 수정해서 새로운 용도를 반영한다.

호출부분이 많으면 수정이 너무 힘들어질 수 있다. 다음 단계를 따라하면 좀 더 매끄럽게 수정할 수 있다.
* 확인된 예외와 미확인 예외 중 어느 것을 사용해야 할지 판단한다.
* 그 예외를 사용하는 새 메서드를 작성한다.
* 원본 메서드의 내용을 수정해서 새 메서드로 호출하게 한다.
* 컴파일과 테스트를 실시한다.
* 원본 메서드 호출을 전부 새 메서드 호출로 바꾼다. 하나씩 수정할 때마다 컴파일과 테스트를 실시한다.
* 원본 메서드를 삭제한다.
<hr/>

### 예외 처리를 테스트로 교체
*호출 부분에 사전 검사 코드를 넣으면 될 상황인데 예외 통지를 사용했을 땐 호출 부분이 사전 검사를 실시하게 수정한다.*
```
double getValueForPeriod (int periodNumber) {
  try {
    return _values[periodNumber];
  } catch (ArrayIndexOutOfBoundsException e) {
    return 0;
  }
}
```
```
double getValueForPeriod (int periodNumber) {
  if (periodNumber >= _values.length) return 0;
  return _values[periodNumber];
}
```
##### 동기
예외 개념의 등장으로 프로그래밍 언어는 크게 진일보했다. 예외 처리 기능 덕택에 개발자는 에러 부호를 예외 통지로 전환을 적용하면 복잡한 코드를 작성하지 않아도 된다. 좋은 것은 항상 과용되기 마련인데, 좋다고 해서 예외를 과다하게 사용하면 더이상 좋은 것이 아니게 된다.

예외처리는 예외적 기능, 즉 예기치 못한 에러에 사용해야 한다. 예외 처리를 조건문 대용으로 사용해선 안 된다. 호출 부분이 메서드를 호출하기 전에 당연히 조건을 검사할 것으로 예상한다면, 개발자는 테스트를 작성해야 하고 호출 부분은 그 테스트를 사용해야 한다.
##### 방법
* 테스트를 앞에 넣고 catch 절의 코드를 if 문의 적절한 절로 복사한다.
* catch 절이 실행되는지 여부가 표시되게 catch 절에 어설션을 넣는다.
* 컴파일과 테스트를 실시한다.
* catct 절을 삭제하고, 다른 catch 절이 없으면 try 절도 삭제한다.
* 컴파일과 테스트를 실시한다.
