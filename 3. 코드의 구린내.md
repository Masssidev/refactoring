# 코드의 구린내
리팩토링을 어떨 때 시작하고 어떨 때 그만둬야 할지 판단하는 일은 리팩토링 기법을 적용하는 방법만큼 중요하다.
<hr/>

### 중복 코드
구린내의 제왕은 누가 뭐래도 중복 코드다. 똑같은 코드 구조가 두 군데 이상 있을 때는 그 부분을 하나로 통일하면 프로그램이 개선된다.

중복 코드의 가장 단순한 예는 한 클래스의 두 메서드 안에 같은 코드가 들어 있는 경우다. 이럴 때는 메서드 추출기법을 적용해서 겹치는 코드를 빼내어 별도의 메서드로 만들고 그 메서드를 두 곳에서 호출하면 된다. 

또 하나의 중복 코드 상황은 한 클래스의 두 하위클래스에 같은 코드가 들어 있는 경우다. 이럴 때는 메서드 추출기법을 적용해서 중복을 없앤 후 메서드 상향기법을 적용하면 된다. 코드가 똑같지 않고 비슷하다면 메서드 추출기법을 적용해서 같은 부분과 다른 부분을 분리해야 한다. 그런 다음, 경우에 따라 템플릿 메서드 형성기법을 적용해야 할 수도 있다. 두 메서드가 알고리즘만 다르고 기능이 같다면 개발자는 그 두 알고리즘 중에서 더 간단한 것을 택해서 알고리즘 전환을 적용하면 된다. 중복 코드가 메서드 가운데에 있다면 주변 메서드 추출을 적용하면 된다. 

서로 상관없는 두 클래스 안에 중복 코드가 있을 때는 한 클래스 안의 중복 코드를 클래스 추출이나 모듈 추출을 적용해 제 3의 클래스나 모듈로 떼어낸 후 그것을 다른 클래스에서 호출하는 방법이 있다. 아니면 중복 코드를 빼서 메서드로 만든 후 그 메서드를 두 클래스 중 하나에 넣고 다른 클래스에서 그 메서드를 호출하거나, 코드를 빼내어 만든 메서드를 제 3의 클래스에 넣고 그걸 두 클래스에서 호출하는 방법도 있다.
<hr/>

### 장황한 메서드
* 최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드 길이가 짧다.
* 메서드를 줄이려면 십중팔구는 메서드 추출기법을 적용해야 한다. 
* 메서드에 매개변수와 임시변수가 많으면 메서드 추출을 실시하기가 까다롭다. 
* 조건문과 루프도 역시 메서드로 빼야 한다.
<hr/>

### 방대한 클래스
기능이 지나치게 많은 클래스에는 보통 엄청난 수의 인스턴스 변수가 들어 있다. 클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련이다.

클래스 추출을 실시하면 수많은 인스턴스 변수를 하나로 묶을 수 있다. 서로 연관된 변수를 골라서 클래스로 빼내면 된다. 
<hr/>

### 과다한 매개변수
객체지향 프로그램은 매개변수 세트가 대체로 구식 프로그램에 비해 훨씬 간결하다.

매개변수 세트가 간결하다는 것은 장점이다. 매개변수 세트가 길면 서로 일관성이 없어지거나 사용이 불편해지고, 더 많은 데이터가 필요해질 때마다 계속 수정해야 하기 때문에 그 매개변수들을 이해하기가 힘들다. 몇 번의 요청만으로 새로운 데이터를 가져올 수 있으므로 객체를 넘기는 것만으로 웬만한 수정은 할 필요가 없어진다.
<hr/>

### 수정의 산발
개발자는 소프트웨어를 수정하기 쉽게 구성한다. 어떻게든 소프트웨어는 말 그대로 소프트해야 하기 때문이다. 수정할 때 개발자는 시스템의 분명한 위치로 곧장 가서 수정할 수 있어야 한다.

변경할 때는 한 개의 클래스나 모듈만 변경해야 하며, 새 클래스나 모듈 안에는 반드시 그 변경사항을 표시해야 한다.
<hr/>

### 기능의 산재
기능의 산재는 수정의 산발과 비슷하지만 정 반대다. 수정할 때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 한다면 이 문제를 의심할 수 있다. 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 꼭 수정해야 하는 부분을 놓치기 쉽다.

수정의 산발은 한 클래스에 여러 수정이 발생하는 문제이고, 기능의 산재는 하나의 수정으로 여러 클래스가 바뀌게 되는 문제다. 둘 중 어느것이든 수정과 클래스가 일대일 대응되게 깔끔히 정리해야 한다.
<hr/>

### 잘못된 소속
객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술이라는 점이다. 전통적으로 어떤 메서드가 자신이 속하지 않은 클래스에 더 많이 접근한다면 잘못된 소속의 구린내가 풍길 것이다. 잘못 소속된 메서드가 제일 흔히 접근하는 대상은 데이터다. 

함께 수정되는 것들을 하나로 뭉친다. 데이터와 그 데이터를 참조하는 기능은 대체로 함께 수정되지만 예외도 있다. 이런 예외가 발생하는 기능은 옮겨서 한 곳에서 수정해야 한다. 
<hr/>

### 데이터 뭉치
데이터 항목은 거리의 꼬마들처럼 몰려다니는 습성이 있다. 몰려 있는 데이터 뭉치는 객체로 만들어야 한다. 
<hr/>

### 강박적 기본 타입 사용
객체의 주요 장점 중 하나가 바로 기본 타입 클래스와 응용 클래스 간의 경계를 허문다는 점이다. 언어에 내장된 기본 타입과 구별하기 힘든 작은 클래스를 손쉽게 작성할 수 있다. 
<hr/>

### switch 문
객체지향 코드의 확연한 특징 중 하나는 switch-case 문이 비교적 적게 사용된다는 점이다. switch 문의 단점은 반드시 중복이 생긴다는 점이다. 

대부분의 switch 문은 고민할 필요 없이 재정의로 바꿔야 한다.
<hr/>

### 평행 상속 계층
평행 상속 계층은 사실 기능의 산재의 특수한 상황이다. 이 문제점이 있으면 한 클래스의 하위클래스를 만들 때마다 매번 다른 클래스의 하위 클래스도 만들어야 한다. 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 이 문제를 의심할 수 있다. 

중복 코드 부분을 제거하려면 보통은 상속 계층의 인스턴스가 다른 상속 계층의 인스턴스를 참조하게 만들면 된다. 
<hr/>

### 직무유기 클래스
하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다. 따라서 비용만큼의 기능을 수행하지 못하는 비효율적 클래스는 없애야 한다. 기존에는 비용 대비 효율성이 좋았으나 리팩토링 실시로 인해 기능이 축소된 클래스, 또는 수정할 계획으로 작성했으나 수정을 실시하지 않아 쓸모없어진 클래스가 바로 이런 직무유기 클래스에 해당된다. 직무 유기 클래스는 깔끔히 제거해야 한다. 
<hr/>

### 막연한 범용 코드
'그래, 조만간 이런 기능이 필요하겠구만'하는 막연한 생각에 아직은 필요 없는 기능을 수행하고자 온갖 호출과 case 문을 넣으려 하는 그 순간 막연한 범용 코드의 구린내가 풍긴다. 
<hr/>

### 임시 필드
어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹 있다. 

임시 필드의 구린내는 복잡한 알고리즘에 여러 변수를 사용해야 할 때 풍긴다. 개발자는 수많은 매개변수를 전달하는 것을 꺼린 나머지, 매개변수를 필드에 대입한다. 그런데 이 인스턴스 변수는 해당 알고리즘이 실행되는 동안에만 효력이 있고 다른 때는 코드를 복잡하게 만들 뿐이다. 
<hr/>

### 메시지 체인
메시지 체인은 클라이언트가 한 객체에 제 2의 객체를 요청하면, 제 2의 객체가 제 3의 객체를 요청하고, 제 3의 객체가 제 4의 객체를 요청하는 식으로 연쇄적 요청이 발생하는 문제점을 뜻한다. 임시변수 세트라고 봐도 된다. 이런 요청의 왕래로 인해 클라이언트는 그 왕래 체제에 구속된다. 그 사이의 관계들에 수정이 발생할 때마다 클라이언트도 수정해야 한다.

이럴 때는 대리 객체 은폐를 실시해야 한다. 이 기법은 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그렇게 하면 모든 중간 객체가 중개 메서드로 변해서 과잉 중개 메서드의 구린내를 풍기는 문제가 흔히 발생한다. 그래서 차라리 결과 객체가 어느 대상에 사용되는지를 알아내는 방법이 더 낫다.
<hr/>

### 과잉 중개 메서드
객체의 주요 특징 한가지는 바로 캡슐화다. 캡슐화란 내부의 세부적인 처리를 외부에서 볼 수 없게 은폐하는 작업을 뜻한다. 캡슐화할 때는 대개 위임이 수반된다.

그러나 이것도 지나치면 문제가 된다. 어떤 클래스의 인터페이스를 보니까 그 안의 절반도 넘는 메서드가 기능을 다른 클래스에 위임하고 있다면, 과잉 중개 메서드 제거를 실시해서 원리가 구현된 객체에 직접 접근해야 한다. 
<hr/>

### 지나친 관여
간혹 클래스끼리 관계가 지나치게 밀접한 나머지 서로의 은밀한 부분을 알아내느라 과도한 시간을 낭비하게 될 때가 있다. 클래스는 엄격하고 절제된 규칙을 따라야 한다. 

서로 지나치게 관여하는 클래스는 갈라놔야 한다. 

상속으로 인해 지나친 관여가 발생하는 경우가 많다. 하위클래스는 항상 상위클래스가 공개하는 것보다 많은 데이터를 필요로 한다. 상위클래스에서 하위클래스를 빼내야 할 경우에는 상속을 위임으로 전환기법을 적용해야 한다.
<hr/>

### 인터페이스가 다른 대용 클래스
기능은 같은데 시그너처가 다른 메스드에는 메서드명 변경을 실시해야 한다. 클래스에 여전히 충분한 기능이 구현되어 있지 않기 때문에 대체로 이 기법만 적용해선 충분하지 않다. 프로토콜이 같아질 때까지 메서드 이동을 실시해서 기능을 해당 클래스로 옮겨야 한다. 단, 코드를 너무 여러 번 옮겨야 한다면 상위클래스 추출을 실시하면 된다.
<hr/>

### 미흡한 라이브러리 클래스
라이브러리 클래스를 원하는 기능을 수행하게 수정하는 것이 보통은 불가능하다. 이 때문에 메서드 이동같은 검증된 방법이 무용지물이 된다. 

이 문제를 해결하기 위해 라이브러리 클래스에 넣어야 할 메서드가 두 개뿐이라면 외래 클래스에 메서드 추가기법을 실시하고, 부가기능이 많을 때는 국소적 상속확장 클래스 사용기법을 실시하면 된다.
<hr/>

### 데이터 클래스
데이터 클래스는 필드와 필드 읽기/쓰기 메서드만 들어 있는 클래스다. 그런 클래스는 오로지 데이터 보관만 담당하며, 거의 대부분의 구체적 데이터 조작은 다른 클래스가 수행한다. 

이런 읽기/쓰기 메서드가 다른 클래스에 의해 사용되는 부분을 찾아서, 메서드 이동을 실시하여 기능을 그 데이터 클래스로 옮겨야 한다. 만약 메서드 전체를 옮길 수 없다면 메서드 추출을 실시해서 옮길 수 있는 메서드를 작성하면 된다. 그러고 나서 읽기/쓰기 메서드에 메서드 은폐를 적용하면 된다.
<hr/>

### 방치된 상속물
하위클래스는 부모 클래스의 메서드와 데이터를 상속받는다. 상속받은 메서드나 데이터가 하위클래스에서 더 이상 쓰이지 않거나 필요 없을 땐 문제가 생긴다. 

이 문제의 원인은 잘못된 계층구조 때문이다. 이럴 경우, 새 대등 클래스를 작성하고 메서드 하향과 필드 하향을 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아 넣으면 된다. 이렇게 하면 상위클래스에는 공통 코드만 들어 있게 된다.
<hr/>

###  불필요한 주석
엄청난 양의 주석이 달린 코드를 보면 그 주석들이 해당 코드의 구린내를 가리기 위해 존재하는 경우가 상당히 많다.

우선 리팩토링을 실시해서 온갖 구린내를 없애야 한다. 대체로 리팩토링을 마친후에야 그 주석들이 불필요한 것이었다는 사실을 알게 된다. 

주석은 무슨 작업을 해야 좋을지 모를 때만 넣는 것이 좋다. 주석을 넣으면 돌아가는 원리를 적어둘 수도 있고 확실치 않은 부분을 표시할 수도 있다. 어떤 코드를 넣은 이유를 메모해 놓을 경우에도 주석을 넣는 것이 적절하다. 이런 정보나 특히 잊기 쉬운 사항을 주석으로 작성해 놓으면 나중에 수정하게 될 사람들이 보고 쉽게 이해할 수 있다. 
> 주석을 넣어야겠다는 생각이 들 땐 먼저 코드를 리팩토링해서 주석을 없앨 수 있게 만들어봐야 한다.
