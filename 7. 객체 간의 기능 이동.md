# 객체 간의 기능 이동
객체 설계에서 원칙은 아니지만 가장 중요한 일 중 하나가 바로 '기능을 어디에 넣을지 판단'하는 것이다. 기능을 넣을 적절한 위치를 판단하는데 서툴다면 리팩토링 기법을 적용하면 된다.
<hr/>

### 메서드 이동
*메서드가 자신이 속한 클래스보다 다른 클래스의 기능을 더 많이 이용할 땐 그 메서드가 제일 많이 이용하는 클래스 안에서 비슷한 애용의 새 메서드를 작성한다. 기존 메서드는 간단한 대리 메서드로 전환하든지 아예 삭제한다.*
##### 동기
메서드 이동은 빛과 소금 같은 리팩토링 기법이다. 클래스에 기능이 너무 많거나 클래스가 다른 클래스와 과하게 연동되어 의존성이 지나칠 때는 메서드를 옮기는 것이 좋다. 메서드를 옮기면 클래스가 간결해지고 여러 기능을 더 명확히 구현할 수 있다. 
##### 방법
* 원본 클래스에 정의되어 있는 원본 메서드에 사용된 모든 기능을 검사한다. 그 기능들도 전부 옮겨야 할지 판단한다.
  * 옮길 메서드에만 사용되는 기능도 그 메서드와 함께 옮겨야 한다. 그 기능이 다른 메서드에도 사용된다면 그 메서드도 함께 옮기는 것을 고려한다. 한 번에 하나씩 옮기는 것보다는 한꺼번에 옮기는 것이 더 간편할 때도 있다. 
* 원본 클래스의 하위클래스와 상위클래스에서 그 메서드에 대한 다른 선언이 있는지 검사한다.
  * 다른 선언이 있다면 대상 클래스에도 재정의를 넣을 수 있을 때만 옮길 수 있을지도 모른다.
* 그 메서드를 대상 클래스 안에 선언한다.
  * 대상 클래스 안에 있을 때 더욱 어울리는 다른 이름으로 그 메서드를 정의해도 된다.
* 원본 메서드의 코드를 대상 메서드에 복사한 후, 대상 클래스 안에서 잘 돌아가게끔 대상 메서드를 약간 수정한다.
  * 대상 메서드가 원본 메서드를 사용한다면 대상 메서드 안에서 원본 객체를 참조할 방법을 정해야 한다. 대상 클래스에 원본 객체를 참조하는 기능이 없다면 원본 객체 참조를 대상 메서드에 매개변수로 전달한다.
  * 대상 메서드에 예외처리 코드가 들어 있다면 예외를 논리적으로 어느 클래스가 처리할지 정한다. 원본 클래스에서 처리하기로 결정했다면 예외처리 코드는 내버려둔다.
* 대상 클래스를 컴파일 한다.
* 원본 객체에서 대상 객체를 참조할 방법을 정한다.
  * 대상 클래스를 참조하는 속성이나 메서드가 이미 존재할 수도 있지만, 혹시 없다면 대상 클래스를 참조하는 메서드를 쉽게 작성할 수 있는지 살펴봐서, 쉽지 않다면 원본 클래스 안에 대상 클래스를 저장할 수 있는 새 속성을 선언해야 한다. 이렇게 수정한 코드를 그대로 둬도 되지만, 리팩토링을 완료할 때까지 임시로 놔뒀다가 나중에 삭제해도 된다.
* 원본 메서드를 위임 메서드로 전환한다.
* 컴파일과 테스트를 실시한다.
* 원본 메서드를 삭제하든지, 아니면 위임 메서드로 사용하게 내버려둔다.
  * 참조가 많을 땐 원본 메서드를 위임 메서드로 내버려두는 방법이 더 편하다.
* 원본 메서드를 삭제할 때는 기존의 참조를 전부 대상 메서드 참조로 수정한다.
  * 각 참조를 하나씩 수정하면서 그때마다 테스트를 실시해도 되지만, 찾아바꾸기 기능을 한 번 실행해서 모든 참조를 한꺼번에 수정하는 것이 더 간편하다.
* 컴파일과 테스트를 실시한다.
##### 예제
###### 원본 클래스의 기능을 사용하기 위한 네 가지 방법
1. 그 기능을 대상 클래스로도 옮긴다.
2. 대상 클래스에서 원본 클래스로의 참조를 생성하거나 사용한다.
3. 원본 객체를 대상 객체에 매개변수로 전달한다.
4. 그 기능이 변수라면 그 변수를 매개변수로 전달한다.
<hr/>

### 필드이동
*어떤 필드가 자신이 속한 클래스보다 다른 클래스에서 더 많이 사용될 때는 대상 클래스 안에 새 필드를 선언하고 그 필드 참조 부분을 전부 새 필드 참조로 수정한다.*
##### 동기
한 클래스에서 다른 클래스로 상태와 기능을 옮기는 것은 리팩토링의 기본이다. 시스템이 발전할수록 새 클래스가 필요해지고 기능을 여기저기로 옮겨야 할 필요성도 생긴다. 

어떤 필드가 자신이 속한 클래스보다 다른 클래스에 있는 메서드를 더 많이 참조해서 정보를 이용한다면 그 필드를 옮기는 것을 생각해봐야 한다. 인터페이스에 따라 메서드를 옮기는 방법을 사용할 수도 있다. 그러나 메서드의 현재 위치가 적절하다고 판단되면 필드를 옮긴다.

클래스 추출을 실시하는 중에도 필드를 옮기는 기법이 수반된다. 이럴 땐 필드가 우선이고 메서드는 다음이다.
##### 방법
* 필드가 public이면 필드 캡슐화기법을 실시한다.
  * 필드에 자주 접근하는 메서드를 옮기게 될 가능성이 높거나 그 필드에 많은 메서드가 접근할 때는 필드 자체 캡슐화를 실시한다.
* 컴파일과 테스트를 실시한다.
* 대상 클래스 안에 읽기/쓰기 메서드와 함께 필드를 작성한다.
* 대상 클래스를 컴파일한다.
* 원본 객체에서 대상 객체를 참조할 방법을 정한다.
  * 기존 필드나 메서드에 대상 클래스를 참조하는 기능이 있을 수도 있다. 만약 없다면 그런 기능의 메서드를 간편히 작성할 수 있는지 살펴봐서, 쉽게 만들 수 없다면 원본 클래스에 대상 클래스를 저장할 수 있는 새 필드를 만들어야 한다. 이러한 수정은 계속 그대로 둬도 되지만, 임시로 만들었다가 리팩토링 완료 후 삭제해도 된다.
* 원본 클래스에서 필드를 삭제한다.
* 원본 필드를 참조하는 모든 부분을 대상 클래스에 있는 적절한 메서드를 참조하게 수정한다.
  * 변수 접근 참조 부분은 대상 객체의 읽기 메서드 호출로 수정하고, 대입 참조 부분은 쓰기 메서드 호출로 수정한다.
  * 필드가 private가 아니면 원본 클래스의 모든 하위클래스를 뒤져서 필드 참조 부분을 찾아낸다.
* 컴파일과 테스트를 실시한다.
##### 예제
자체 캡슐화 기법을 사용하면 과정이 단축된다. 자체 캡슐화는 클래스로 많은 작업을 수행할 때 사용하면 좋다. 특히 자체 캡슐화를 실시하면 메서드를 대상 클래스로 옮기는 메서드 이동기법의 사용이 간편해진다. 메서드가 읽기/쓰기 메서드를 참조할 경우, 그 참조는 필드 자체 캡슐화를 수정할 필요가 없다.
<hr/>

### 클래스 추출
*두 클래스가 처리해야 할 기능이 하나의 클래스에 들어 있을 땐 새 클래스를 만들고 기존 클래스의 관련 필드와 메서드를 새 클래스로 옮긴다.*
##### 동기
클래스는 확실하게 추상화되어야 하며, 두세 가지의 명확한 기능을 담당해야 한다.

클래스의 어느 부분을 분리할지 궁리해서 떼어내야 한다. 데이터의 일부분과 메서드의 일부분이 한 덩어리이거나, 주로 함께 변화하거나 서로 유난히 의존적인 데이터의 일부분도 클래스로 떼어내기 좋다.
##### 방법
* 클래스의 기능 분리 방법을 정한다.
* 분리한 기능을 넣을 새 클래스를 작성한다.
  * 원본 클래스의 기능이 이름과 어울리지 않게 바뀌었으면 원본 클래스의 이름을 변경한다.
* 원본 클래스에서 새 클래스로의 링크를 만든다.
  * 양방향 링크를 만들어야 할 수도 있는데, 필요할 때까진 역방향 링크를 만들지 않는다.
* 옮길 필드마다 필드 이동을 적용한다.
* 필드를 하나씩 옮길 때마다 컴파일과 테스트를 실시한다.
* 메서드 이동을 실시해서 원본 클래스의 메서드를 새 클래스로 옮긴다. 하급 메서드(피호출 메서드)부터 시작해서 상급 메서드(호출 메서드)에 적용한다.
* 메서드 이동을 실시할 때마다 테스트를 실시한다.
* 각 클래스를 다시 검사해서 인터페이스를 줄인다.
  * 양방향 링크가 있다면 그것을 단방향으로 바꿀 수 있는지 알아본다.
* 여러 곳에서 클래스에 접근할 수 있게 할지 결정한다. 여러 곳에서 접근할 수 있게 할 경우, 새 클래스를 참조 객체나 변경불가 값 객체로서 공개할지 여부를 결정한다.
##### 예제
클래스 추출은 두 결과 클래스에 따로 락을 걸 수 있어서 병렬 실행 프로그램의 생동감을 향상시키는 용도로 흔히 사용되는 기법이다. 두 객체에 락을 걸 필요가 없다면 이 기법을 실시하지 않아도 된다. 

그러나 이 방법에도 위험성은 있다. 두 객체에 동시에 락을 걸어야 할 경우는 트랜잭션과 다른 종류의 공유 락 영역으로 넘어가게 된다. 이것은 복잡한 영역이며 대부분 얻는 것에 비해 많은 작업을 요한다. 트랜잭션은 사용하기엔 좋지만, 트랜잭션 관리자를 작성하는 일은 웬만한 프로그래머가 하기엔 부적합한 일이다. 
<hr/>

### 클래스 내용 직접 삽입
*클래스에 기능이 너무 적을 땐 그 클래스의 모든 기능을 다른 클래스로 합쳐 넣고 원래의 클래스는 삭제한다.*
##### 동기
클래스 내용 직접 삽입은 클래스 추출과 반대다. 클래스 내용 직접 삽입은 클래스가 더 이상 제 역할을 수행하지 못하여 존재할 이유가 없을 때 실시한다. 이런 상황은 주로 클래스의 기능 대부분을 다른 곳으로 옮기는 리팩토링을 실시해서 남은 기능이 거의 없어졌을 때 나타난다. 이럴 때는 이 작은 클래스를 가장 많이 사용하는 다른 클래스를 하나 고른 후, 이 클래스를 거기에 합쳐야 한다.
##### 방법
* 원본 클래스의 public 프로토콜 메서드를 합칠 클래스에 선언하고, 이 메서드를 전부 원본 클래스에 위임한다.
  * 원본 클래스의 메서드 대신 별도의 인터페이스가 알맞다고 판단되면 클래스 내용 직접 삽입을 실시하기 전에 인터페이스 추출기법을 실시한다.
* 원본 클래스의 모든 참조를 합칠 클래스 참조로 수정한다.
  * 원본 클래스를 private로 선언하고 패키지 밖의 참조를 삭제한다. 컴파일러가 껍데기만 남은 원본 클래스 참조를 찾아낼 수 있게 원본 클래스명을 변경한다.
* 컴파일과 테스트를 실시한다.
* 메서드 이동과 필드 이동을 실시해서 원본 클래스의 모든 기능을 합칠 클래스로 차례로 옯긴다.
* 원본 클래스를 삭제한다.
<hr/>

### 대리 객체 은폐
*클라이언트가 객체의 대리 클래스를 호출할 땐 대리 클래스를 감추는 메서드를 서버에 작성한다.*
##### 동기
객체에서 핵심 개념 중 하나가 바로 캡슐화다. 캡슐화란 객체가 시스템의 다른 부분에 대한 정보의 일부만 알 수 있게 은폐하는 것을 뜻한다. 객체를 캡슐화하면 무언가를 변경할 때 그 변화를 전달해야 할 객체가 줄어들므로 변경하기 쉬워진다.

클라이언트가 서버 객체의 필드 중 하나에 정의된 메서드를 호출할 때 그 클라이언트는 이 대리 객체에 관해 알아야 한다. 대리 객체가 변경될 때 클라이언트도 변경해야 할 가능성이 있기 때문이다. 이런 의존성을 없애려면, 대리 객체를 감추는 간단한 위임 메서드를 서버에 두면 된다. 변경은 서버에만 이뤄지고 클라이언트에는 영향을 주지 않는다. 

서버의 일부 클라이언트나 모든 클라이언트에 대리 객체 은폐를 실시하는 것이 좋을 때도 있다. 모든 클라이언트를 대상으로 대리 객체를 감출 경우에는 서버의 인터페이스에서 대리 객체에 대한 모든 부분을 삭제해도 된다.
##### 방법
* 대리 객체에 들어 있는 각 메서드를 대상으로 서버에 간단한 위임 메서드를 작성한다.
* 클라이언트를 수정해서 서버를 호출하게 만든다.
  * 클라이언트 클래스가 서버 클래스와 같은 패키지에 들어 있지 않다면 대리 메서드의 접근을 같은 패키지에 든 클래스만 접근할 수 있게 수정하는 것을 고려한다.
* 각 메서드를 수정할 때마다 컴파일과 테스트를 실시한다.
* 대리 객체를 읽고 써야 할 클라이언트가 하나도 남지 않게 되면, 서버에서 대리 객체가 사용하는 읽기/쓰기 메서드를 삭제한다.
* 컴파일과 테스트를 실시한다.
<hr/>

### 과잉 중개 메서드 제거
*클래스에 자잘한 위임이 너무 많을 땐 대리 객체를 클라이언트가 직접 호출하게 한다.*
##### 동기
대리 객체 은폐 기법은 장점을 얻는 대신 단점도 생긴다. 클라이언트가 대리 객체의 새 기능을 사용해야 할 때마다 서버에 간단한 위임 메서드를 추가해야 한다는 점이다. 기능을 추가한 후 한동안은 고생하게 된다. 서버 클래스는 그저 중개자에 불과하므로, 이때는 클라이언트가 대리 객체를 직접 호출하게 해야 한다.
##### 방법
* 대리 객체에 대한 접근 메서드를 작성한다.
* 대리 메서드를 클라이언트가 사용할 때마다 서버에서 메서드를 제거하고 클라이언트에서의 호출을 개리 객체에서의 메서드 호출로 교체한다.
* 메서드를 수정할 때마다 테스트를 실시한다.
##### 예제
편의상 일부 위임 메서드는 그대로 둬야 할 때도 있다. 대리 객체를 일부 클라이언트에게만 감추고 나머지 클라이언트에겐 공개해야 할 때도 있다. 이럴 때는 간단한 위임 메서드 중 일부를 그대로 내버려두면 된다.
<hr/>

### 외래 클래스에 메서드 추가
*사용 중인 서버 클래스에 메서드를 추가해야 하는데 그 클래스를 수정할 수 없을 땐 클라이언트 클래스 안에 서버 클래스의 인스턴스를 첫 번째 인자로 받는 메서드를 작성한다.*
```
Date newStart = new Date (previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + 1);
```
```
Date newStart = nextDay(previousEnd);

private static Date nextDay(Date arg) {
 return new Date (arg.getYear(), arg.getMonth(), arg.getDate() + 1);
}
```
##### 동기
현재 사용하고 잇는 클래스엔 모든 기능이 있다. 그러다가 현재의 클래스엔 없는 한가지 기능이 필요해졌다. 원본 클래스가 수정 가능하다면 그 기능의 메서드를 추가하면 된다. 하지만 원본 클래스를 수정할 수 없다면 그 메서드를 클라이언트 클래스 안에 작성해야 한다.

필요한 메서드를 클라이언트 클래스 안에서 한 번만 사용한다면 추가 코딩은 별 문제가 아니고 원본 클래스에는 필요가 없을 것이다. 하지만 메서드를 여러 번 사용한다면 이 코드를 여기저기에 중복되게 작성해야 할 것이다. 중복 코드는 모든 소프트웨어를 악화시키는 근원이므로 이런 중복 코드는 하나의 메서드로 만들어야 한다. 이 리팩토링 기법을 실시할 때 새로 만들 메서드를 외래 메서드로 만들면 그 메서드가 원래는 원본 메서드인 서버 메서드에 있어야 할 메서드임을 분명히 나타낼 수 있다. 

서버 클래스에 수많은 외래 메서드를 작성해야 하거나 하나의 외래 메서드를 여러 클래스가 사용해야 할 때는 이 기법 대신 국소적 상속확장 클래스 사용기법을 실시해야 한다.

외래 메서드는 임시방편에 불과하다. 가능하면 외래 메서드를 원래 있어야 할 위치로 옯겨 본다.
##### 방법
* 필요한 기능의 메서드를 클라이언트 클래스 안에 작성한다.
  * 그 메서드는 클라이언트 클래스의 어느 기능에도 접근해선 안 된다. 그 메서드에 값이 필요할 땐 매개변수로 전달해야 한다.
* 서버 클래스의 인스턴스를 첫 번째 매개변수로 만든다.
* 그 메서드에 '서버 클래스에 있을 외래 메서드'같은 주석을 단다.
  * 이렇게 하면 나중에 그 외래 메서드를 옮길 일이 생겼을 때 문자열 검색 기능으로 외래 메서드를 쉽게 찾을 수 있다.
<hr/>

### 국소적 상속확장 클래스 사용
*사용중인 서버 클래스에 여러 개의 메서드를 추가해야 하는데 클래스를 수정할 수 없을 땐 새 클래스를 작성하고 그 안에 필요한 여러 개의 메서드를 작성한다. 이 상속확장 클래스를 원본 클래스의 하위클래스나 래퍼 클래스로 만든다.*
##### 동기
원본 클래스를 수정하는 것은 불가능할 때가 대부분이다. 필요한 메서드가 한두 개일 때는 외래 클래스에 메서드 추가기법을 실시하면 되지만 메서드 수가 세 개 이상이면 무리다. 그러므로 필요한 메서드들을 적당한 곳에 모아둬야 한다. 이렇게 하는 확실한 방법은 보편적인 객체지향 기법인 하위클래스화와 래퍼화를 실시하는 것이다. 이렇게 만든 하위클래스와 래퍼 클래스를 국소적 상속확장 클래스라고 부른다.

국소적 상속확장 클래스는 별도의 클래스지만 상속확장하는 클래스의 하위 타입이다. 따라서 국소적 상속확장 클래스는 원본 클래스의 모든 기능도 사용 가능하면서 추가 기능도 들어 있다. 원본 클래스를 사용할 것이 아니라 국소적 상속확장 클래스를 인스턴스화해서 사용한다.

국소적 상속확장 클래스를 사용하면 메서드와 데이터가 체계적인 단위로 묶여야 한다는 원칙이 저절로 지켜진다. 필요한 메서드가 국소적 상속확장 클래스 안에 있어야 함에도 불구하고 엉뚱한 클래스에 들어 있는 상태로 방치하면 그 엉뚱한 클래스들이 복잡해져서 그 메서드는 재사용하기 힘들어진다.

하위클래스와 래퍼 클래스 중에서 작업량이 적은 하위클래스를 권장한다. 하위클래스를 만드는 방식의 문제점은 객체를 생성함과 동시에 하위클래스로 만들어야 한다는 점이다. 하위클래스로 만들려면 그 하위클래스의 새 객체를 생성해야 한다. 다른 객체가 기존 클래스를 참조한다면 원본 클래스의 데이터가 든 객체가 두 개임을 알 수 있다. 원본 객체가 변경불가 상태이면 안심하고 복사하면 된다. 그러나 원본 객체가 변경할 수 있는 상태이면 한 객체를 수정해도 다른 객체가 수정되지 않아 문제가 된다. 따라서 래퍼 클래스를 사용해야 한다. 그러면 국소적 상속확장 클래스를 통해 이뤄진 수정이 원본 객체에도 반영되고, 그 반대로도 반영된다.
##### 방법
* 상속확장 클래스를 작성한 후 원본 클래스의 하위클래스나 래퍼 클래스로 만든다.
* 상속확장 클래스에 변환 생성자(하나의 인자를 받는 생성자 메서드가 그 인자의 타입을 해당 클래스 타입으로 변환할 때 그 생성자 메서드를 변환생성자라고 한다.) 메서드를 작성한다.
  * 생성자는 원본 클래스를 인자로 받는다. 하위클래스의 경우 적절한 상위클래스 생성자를 호출하며, 래퍼 클래스의 경우 대리 필드에 그 인자를 할당한다.
* 상속확장 클래스에 새 기능을 추가한다.
* 필요한 위치마다 원본 클래스를 상속확장 클래스로 수정한다.
* 이 클래스용으로 정의된 외래 메서드를 전부 상속확장 클래스로 옮긴다.
##### 예제
* 래퍼 클래스 사용 부분은 래퍼 클래스에 전혀 관여해선 안 되며 원본과 래퍼를 동등하게 다룰 수 있어야 한다. 하지만 래퍼 클래스 사용 사실을 완벽히 감추진 못한다. 
* 기능을 재정의하지 않는 이상, 하위클래스화 방식을 사용할 땐 문제가 없다. 그러나 기능을 재정의하면 메서드를 검색할 때 정말 애먹게 된다. 상속확장 클래스를 사용할 땐 메서드를 재정의하지 않고 그냥 메서드를 추가하는 것이 좋다.
